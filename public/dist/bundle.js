/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/nonIterableRest.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectSpread.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectSpread.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var defineProperty = __webpack_require__(/*! ./defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nmodule.exports = _objectSpread;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/objectSpread.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var objectWithoutPropertiesLoose = __webpack_require__(/*! ./objectWithoutPropertiesLoose */ \"./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/objectWithoutProperties.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\n\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\n\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/slicedToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "./node_modules/kontra/kontra.js":
/*!***************************************!*\
  !*** ./node_modules/kontra/kontra.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("kontra = {\n\n  /**\n   * Initialize the canvas.\n   * @memberof kontra\n   *\n   * @param {string|HTMLCanvasElement} canvas - Main canvas ID or Element for the game.\n   */\n  init(canvas) {\n\n    // check if canvas is a string first, an element next, or default to getting\n    // first canvas on page\n    var canvasEl = this.canvas = document.getElementById(canvas) ||\n                                 canvas ||\n                                 document.querySelector('canvas');\n\n    // @if DEBUG\n    if (!canvasEl) {\n      throw Error('You must provide a canvas element for the game');\n    }\n    // @endif\n\n    this.context = canvasEl.getContext('2d');\n    this.context.imageSmoothingEnabled = false;\n    this._init();\n  },\n\n  /**\n   * Noop function.\n   * @see https://stackoverflow.com/questions/21634886/what-is-the-javascript-convention-for-no-operation#comment61796464_33458430\n   * @memberof kontra\n   * @private\n   *\n   * The new operator is required when using sinon.stub to replace with the noop.\n   */\n  _noop: new Function,\n\n  /**\n   * Dispatch event to any part of the code that needs to know when\n   * a new frame has started. Will be filled out in pointer events.\n   * @memberOf kontra\n   * @private\n   */\n  _tick: new Function,\n\n  /**\n   * Dispatch event to any part of the code that needs to know when\n   * kontra has initialized. Will be filled out in pointer events.\n   * @memberOf kontra\n   * @private\n   */\n  _init: new Function\n};\n(function() {\n  let imageRegex = /(jpeg|jpg|gif|png)$/;\n  let audioRegex = /(wav|mp3|ogg|aac)$/;\n  let noRegex = /^no$/;\n  let leadingSlash = /^\\//;\n  let trailingSlash = /\\/$/;\n  let assets;\n\n  // audio playability\n  // @see https://github.com/Modernizr/Modernizr/blob/master/feature-detects/audio.js\n  let audio = new Audio();\n  let canUse = {\n    wav: '',\n    mp3: audio.canPlayType('audio/mpeg;').replace(noRegex,''),\n    ogg: audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(noRegex,''),\n    aac: audio.canPlayType('audio/aac;').replace(noRegex,'')\n  };\n\n  /**\n   * Join a base path and asset path.\n   *\n   * @param {string} base - The asset base path.\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function joinPath(base, url) {\n    return [base.replace(trailingSlash, ''), base ? url.replace(leadingSlash, '') : url]\n      .filter(s => s)\n      .join('/')\n  }\n\n  /**\n   * Get the extension of an asset.\n   *\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function getExtension(url) {\n    return url.split('.').pop();\n  }\n\n  /**\n   * Get the name of an asset.\n   *\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function getName(url) {\n    let name = url.replace('.' + getExtension(url), '');\n\n    // remove leading slash if there is no folder in the path\n    // @see https://stackoverflow.com/a/50592629/2124254\n    return name.split('/').length == 2 ? name.replace(leadingSlash, '') : name;\n  }\n\n  /**\n   * Load an Image file. Uses imagePath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string} url - The URL to the Image file.\n   *\n   * @returns {Promise} A deferred promise. Promise resolves with the Image.\n   *\n   * @example\n   * kontra.loadImage('car.png');\n   * kontra.loadImage('autobots/truck.png');\n   */\n  function loadImage(originalUrl, url) {\n    return new Promise(function(resolve, reject) {\n      let image = new Image();\n      url = joinPath(assets.imagePath, originalUrl);\n\n      image.onload = function loadImageOnLoad() {\n        let fullUrl = assets._u(url, window.location.href);\n        assets.images[ getName(originalUrl) ] = assets.images[url] = assets.images[fullUrl] = this;\n        resolve(this);\n      };\n\n      image.onerror = function loadImageOnError() {\n        reject(/* @if DEBUG */ 'Unable to load image ' + /* @endif */ url);\n      };\n\n      image.src = url;\n    });\n  }\n\n  /**\n   * Load an Audio file. Supports loading multiple audio formats which will be resolved by\n   * the browser in the order listed. Uses audioPath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string|string[]} url - The URL to the Audio file.\n   *\n   * @returns {Promise} A deferred promise. Promise resolves with the Audio.\n   *\n   * @example\n   * kontra.loadAudio('sound_effects/laser.mp3');\n   * kontra.loadAudio(['explosion.mp3', 'explosion.m4a', 'explosion.ogg']);\n   */\n  function loadAudio(originalUrl, url, undefined) {\n    return new Promise(function(resolve, reject) {\n\n      // determine which audio format the browser can play\n      originalUrl = [].concat(originalUrl).reduce(function(a, source) {\n        return canUse[ getExtension(source) ] ? source : a\n      }, undefined);\n\n      if (!originalUrl) {\n        reject(/* @if DEBUG */ 'cannot play any of the audio formats provided' + /* @endif */ originalUrl);\n      }\n      else {\n        let audio = new Audio();\n        url = joinPath(assets.audioPath, originalUrl);\n\n        audio.addEventListener('canplay', function loadAudioOnLoad() {\n          let fullUrl = assets._u(url, window.location.href);\n          assets.audio[ getName(originalUrl) ] = assets.audio[url] = assets.audio[fullUrl] = this;\n          resolve(this);\n        });\n\n        audio.onerror = function loadAudioOnError() {\n          reject(/* @if DEBUG */ 'Unable to load audio ' + /* @endif */ url);\n        };\n\n        audio.src = url;\n        audio.load();\n      }\n    });\n  }\n\n  /**\n   * Load a data file (be it text or JSON). Uses dataPath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string} url - The URL to the data file.\n   *\n   * @returns {Promise} A deferred promise. Resolves with the data or parsed JSON.\n   *\n   * @example\n   * kontra.loadData('bio.json');\n   * kontra.loadData('dialog.txt');\n   */\n  function loadData(originalUrl, url) {\n    url = joinPath(assets.dataPath, originalUrl);\n\n    return fetch(url).then(function(response) {\n      if (!response.ok) throw response;\n      return response.clone().json().catch(function() { return response.text() })\n    }).then(function(data) {\n      let fullUrl = assets._u(url, window.location.href);\n      if (typeof data === 'object') {\n        assets._d.set(data, fullUrl);\n      }\n\n      assets.data[ getName(originalUrl) ] = assets.data[url] = assets.data[fullUrl] = data;\n      return data;\n    });\n  }\n\n  /**\n   * Object for loading assets.\n   */\n  assets = kontra.assets = {\n    // all assets are stored by name as well as by URL\n    images: {},\n    audio: {},\n    data: {},\n    _d: new WeakMap(),\n    _u(url, base) {\n      return new URL(url, base).href;\n    },\n\n    // base asset path for determining asset URLs\n    imagePath: '',\n    audioPath: '',\n    dataPath: '',\n\n    /**\n     * Load an Image, Audio, or data file.\n     * @memberOf kontra.assets\n     *\n     * @param {string|string[]} - Comma separated list of assets to load.\n     *\n     * @returns {Promise}\n     *\n     * @example\n     * kontra.loadAsset('car.png');\n     * kontra.loadAsset(['explosion.mp3', 'explosion.ogg']);\n     * kontra.loadAsset('bio.json');\n     * kontra.loadAsset('car.png', ['explosion.mp3', 'explosion.ogg'], 'bio.json');\n     */\n    load() {\n      let promises = [];\n      let url, extension, asset, i, promise;\n\n      for (i = 0; (asset = arguments[i]); i++) {\n        url = [].concat(asset)[0];\n\n        extension = getExtension(url);\n        if (extension.match(imageRegex)) {\n          promise = loadImage(asset);\n        }\n        else if (extension.match(audioRegex)) {\n          promise = loadAudio(asset);\n        }\n        else {\n          promise = loadData(asset);\n        }\n\n        promises.push(promise);\n      }\n\n      return Promise.all(promises);\n    },\n\n    // expose properties for testing\n    /* @if DEBUG */\n    _canUse: canUse\n    /* @endif */\n  };\n})();\n(function() {\n\n  /**\n   * Game loop that updates and renders the game every frame.\n   * @memberof kontra\n   *\n   * @param {object}   properties - Properties of the game loop.\n   * @param {number}   [properties.fps=60] - Desired frame rate.\n   * @param {boolean}  [properties.clearCanvas=true] - Clear the canvas every frame.\n   * @param {function} properties.update - Function called to update the game.\n   * @param {function} properties.render - Function called to render the game.\n   */\n  kontra.gameLoop = function(properties) {\n    properties = properties || {};\n\n    // check for required functions\n    // @if DEBUG\n    if ( !(properties.update && properties.render) ) {\n      throw Error('You must provide update() and render() functions');\n    }\n    // @endif\n\n    // animation variables\n    let fps = properties.fps || 60;\n    let accumulator = 0;\n    let delta = 1E3 / fps;  // delta between performance.now timings (in ms)\n    let step = 1 / fps;\n\n    let clear = (properties.clearCanvas === false ?\n                kontra._noop :\n                function clear() {\n                  kontra.context.clearRect(0,0,kontra.canvas.width,kontra.canvas.height);\n                });\n    let last, rAF, now, dt;\n\n    /**\n     * Called every frame of the game loop.\n     */\n    function frame() {\n      rAF = requestAnimationFrame(frame);\n\n      now = performance.now();\n      dt = now - last;\n      last = now;\n\n      // prevent updating the game with a very large dt if the game were to lose focus\n      // and then regain focus later\n      if (dt > 1E3) {\n        return;\n      }\n\n      kontra._tick();\n      accumulator += dt;\n\n      while (accumulator >= delta) {\n        gameLoop.update(step);\n\n        accumulator -= delta;\n      }\n\n      clear();\n      gameLoop.render();\n    }\n\n    // game loop object\n    let gameLoop = {\n      update: properties.update,\n      render: properties.render,\n      isStopped: true,\n\n      /**\n       * Start the game loop.\n       * @memberof kontra.gameLoop\n       */\n      start() {\n        last = performance.now();\n        this.isStopped = false;\n        requestAnimationFrame(frame);\n      },\n\n      /**\n       * Stop the game loop.\n       */\n      stop() {\n        this.isStopped = true;\n        cancelAnimationFrame(rAF);\n      },\n\n      // expose properties for testing\n      // @if DEBUG\n      _frame: frame,\n      set _last(value) {\n        last = value;\n      }\n      // @endif\n    };\n\n    return gameLoop;\n  };\n})();\n(function() {\n  let callbacks = {};\n  let pressedKeys = {};\n\n  let keyMap = {\n    // named keys\n    13: 'enter',\n    27: 'esc',\n    32: 'space',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down'\n  };\n\n  // alpha keys\n  // @see https://stackoverflow.com/a/43095772/2124254\n  for (let i = 0; i < 26; i++) {\n    keyMap[65+i] = (10 + i).toString(36);\n  }\n  // numeric keys\n  for (i = 0; i < 10; i++) {\n    keyMap[48+i] = ''+i;\n  }\n\n  addEventListener('keydown', keydownEventHandler);\n  addEventListener('keyup', keyupEventHandler);\n  addEventListener('blur', blurEventHandler);\n\n  /**\n   * Execute a function that corresponds to a keyboard key.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keydownEventHandler(e) {\n    let key = keyMap[e.which];\n    pressedKeys[key] = true;\n\n    if (callbacks[key]) {\n      callbacks[key](e);\n    }\n  }\n\n  /**\n   * Set the released key to not being pressed.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keyupEventHandler(e) {\n    pressedKeys[ keyMap[e.which] ] = false;\n  }\n\n  /**\n   * Reset pressed keys.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function blurEventHandler(e) {\n    pressedKeys = {};\n  }\n\n  /**\n   * Object for using the keyboard.\n   */\n  kontra.keys = {\n    map: keyMap,\n\n    /**\n     * Register a function to be called on a key press.\n     * @memberof kontra.keys\n     *\n     * @param {string|string[]} keys - key or keys to bind.\n     */\n    bind(keys, callback) {\n      // smaller than doing `Array.isArray(keys) ? keys : [keys]`\n      [].concat(keys).map(function(key) {\n        callbacks[key] = callback;\n      })\n    },\n\n    /**\n     * Remove the callback function for a key.\n     * @memberof kontra.keys\n     *\n     * @param {string|string[]} keys - key or keys to unbind.\n     */\n    unbind(keys, undefined) {\n      [].concat(keys).map(function(key) {\n        callbacks[key] = undefined;\n      })\n    },\n\n    /**\n     * Returns whether a key is pressed.\n     * @memberof kontra.keys\n     *\n     * @param {string} key - Key to check for press.\n     *\n     * @returns {boolean}\n     */\n    pressed(key) {\n      return !!pressedKeys[key];\n    }\n  };\n})();\n(function() {\n  let pointer;\n\n  // save each object as they are rendered to determine which object\n  // is on top when multiple objects are the target of an event.\n  // we'll always use the last frame's object order so we know\n  // the finalized order of all objects, otherwise an object could ask\n  // if it's being hovered when it's rendered first even if other objects\n  // would block it later in the render order\n  let thisFrameRenderOrder = [];\n  let lastFrameRenderOrder = [];\n\n  let callbacks = {};\n  let trackedObjects = [];\n  let pressedButtons = {};\n\n  let buttonMap = {\n    0: 'left',\n    1: 'middle',\n    2: 'right'\n  };\n\n  /**\n   * Detection collision between a rectangle and a circle.\n   * @see https://yal.cc/rectangle-circle-intersection-test/\n   * @private\n   *\n   * @param {object} object - Object to check collision against.\n   */\n  function circleRectCollision(object) {\n    let x = object.x;\n    let y = object.y;\n    if (object.anchor) {\n      x -= object.width * object.anchor.x;\n      y -= object.height * object.anchor.y;\n    }\n\n    let dx = pointer.x - Math.max(x, Math.min(pointer.x, x + object.width));\n    let dy = pointer.y - Math.max(y, Math.min(pointer.y, y + object.height));\n    return (dx * dx + dy * dy) < (pointer.radius * pointer.radius);\n  }\n\n  /**\n   * Get the first on top object that the pointer collides with.\n   * @private\n   *\n   * @returns {object} First object to collide with the pointer.\n   */\n  function getCurrentObject() {\n\n    // if pointer events are required on the very first frame or without a game loop,\n    // use the current frame order array\n    let frameOrder = (lastFrameRenderOrder.length ? lastFrameRenderOrder : thisFrameRenderOrder);\n    let length = frameOrder.length - 1;\n    let object, collides;\n\n    for (let i = length; i >= 0; i--) {\n      object = frameOrder[i];\n\n      if (object.collidesWithPointer) {\n        collides = object.collidesWithPointer(pointer);\n      }\n      else {\n        collides = circleRectCollision(object);\n      }\n\n      if (collides) {\n        return object;\n      }\n    }\n  }\n\n  /**\n   * Execute the onDown callback for an object.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function pointerDownHandler(e) {\n\n    // touchstart should be treated like a left mouse button\n    let button = e.button !== undefined ? buttonMap[e.button] : 'left';\n    pressedButtons[button] = true;\n    pointerHandler(e, 'onDown');\n  }\n\n  /**\n   * Execute the onUp callback for an object.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function pointerUpHandler(e) {\n    let button = e.button !== undefined ? buttonMap[e.button] : 'left';\n    pressedButtons[button] = false;\n    pointerHandler(e, 'onUp');\n  }\n\n  /**\n   * Track the position of the mouse.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function mouseMoveHandler(e) {\n    pointerHandler(e, 'onOver');\n  }\n\n  /**\n   * Reset pressed buttons.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function blurEventHandler(e) {\n    pressedButtons = {};\n  }\n\n  /**\n   * Find the first object for the event and execute it's callback function\n   * @private\n   *\n   * @param {Event} e\n   * @param {string} event - Which event was called.\n   */\n  function pointerHandler(e, event) {\n    if (!kontra.canvas) return;\n\n    let clientX, clientY;\n\n    if (['touchstart', 'touchmove', 'touchend'].indexOf(e.type) !== -1) {\n      clientX = (e.touches[0] || e.changedTouches[0]).clientX;\n      clientY = (e.touches[0] || e.changedTouches[0]).clientY;\n    } else {\n      clientX = e.clientX;\n      clientY = e.clientY;\n    }\n\n    let ratio = kontra.canvas.height / kontra.canvas.offsetHeight;\n    let rect = kontra.canvas.getBoundingClientRect();\n    let x = (clientX - rect.left) * ratio;\n    let y = (clientY - rect.top) * ratio;\n\n    pointer.x = x;\n    pointer.y = y;\n\n    let object;\n    if (e.target === kontra.canvas) {\n      e.preventDefault();\n      object = getCurrentObject();\n      if (object && object[event]) {\n        object[event](e);\n      }\n    }\n\n    if (callbacks[event]) {\n      callbacks[event](e, object);\n    }\n  }\n\n  /**\n   * Object for using the pointer.\n   */\n  pointer = kontra.pointer = {\n    x: 0,\n    y: 0,\n    radius: 5,  // arbitrary size\n\n    /**\n     * Register object to be tracked by pointer events.\n     * @memberof kontra.pointer\n     *\n     * @param {object|object[]} objects - Object or objects to track.\n     */\n    track(objects) {\n      [].concat(objects).map(function(object) {\n\n        // override the objects render function to keep track of render order\n        if (!object._r) {\n          object._r = object.render;\n\n          object.render = function() {\n            thisFrameRenderOrder.push(this);\n            this._r();\n          };\n\n          trackedObjects.push(object);\n        }\n      });\n    },\n\n    /**\n     * Remove object from being tracked by pointer events.\n     * @memberof kontra.pointer\n     *\n     * @param {object|object[]} objects - Object or objects to stop tracking.\n     */\n    untrack(objects, undefined) {\n      [].concat(objects).map(function(object) {\n\n        // restore original render function to no longer track render order\n        object.render = object._r;\n        object._r = undefined;\n\n        let index = trackedObjects.indexOf(object);\n        if (index !== -1) {\n          trackedObjects.splice(index, 1);\n        }\n      })\n    },\n\n    /**\n     * Returns whether a tracked object is under the pointer.\n     * @memberof kontra.pointer\n     *\n     * @param {object} object - Object to check\n     *\n     * @returns {boolean}\n     */\n    over(object) {\n      if (trackedObjects.indexOf(object) === -1) return false;\n\n      return getCurrentObject() === object;\n    },\n\n    /**\n     * Register a function to be called on pointer down.\n     * @memberof kontra.pointer\n     *\n     * @param {function} callback - Function to execute\n     */\n    onDown(callback) {\n      callbacks.onDown = callback;\n    },\n\n    /**\n     * Register a function to be called on pointer up.\n     * @memberof kontra.pointer\n     *\n     * @param {function} callback - Function to execute\n     */\n    onUp(callback) {\n      callbacks.onUp = callback;\n    },\n\n    /**\n     * Returns whether the button is pressed.\n     * @memberof kontra.pointer\n     *\n     * @param {string} button - Button to check for press.\n     *\n     * @returns {boolean}\n     */\n    pressed(button) {\n      return !!pressedButtons[button]\n    }\n  };\n\n  // reset object render order on every new frame\n  kontra._tick = function() {\n    lastFrameRenderOrder.length = 0;\n\n    thisFrameRenderOrder.map(function(object) {\n      lastFrameRenderOrder.push(object);\n    });\n\n    thisFrameRenderOrder.length = 0;\n  };\n\n  // After the canvas is chosen, add events to it\n  kontra._init = function() {\n    kontra.canvas.addEventListener('mousedown', pointerDownHandler);\n    kontra.canvas.addEventListener('touchstart', pointerDownHandler);\n    kontra.canvas.addEventListener('mouseup', pointerUpHandler);\n    kontra.canvas.addEventListener('touchend', pointerUpHandler);\n    kontra.canvas.addEventListener('blur', blurEventHandler);\n    kontra.canvas.addEventListener('mousemove', mouseMoveHandler);\n    kontra.canvas.addEventListener('touchmove', mouseMoveHandler);\n  }\n})();\n\n(function() {\n\n  /**\n   * Object pool. The pool will grow in size to accommodate as many objects as are needed.\n   * Unused items are at the front of the pool and in use items are at the end of the pool.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the pool.\n   * @param {function} properties.create - Function that returns the object to use in the pool.\n   * @param {number} properties.maxSize - The maximum size that the pool will grow to.\n   */\n  kontra.pool = function(properties) {\n    properties = properties || {};\n\n    let inUse = 0;\n\n    // check for the correct structure of the objects added to pools so we know that the\n    // rest of the pool code will work without errors\n    // @if DEBUG\n    let obj;\n    if (!properties.create ||\n        ( !( obj = properties.create() ) ||\n          !( obj.update && obj.init &&\n             obj.isAlive )\n       )) {\n      throw Error('Must provide create() function which returns an object with init(), update(), and isAlive() functions');\n    }\n    // @endif\n\n    return {\n      _c: properties.create,\n\n      // start the pool with an object\n      objects: [properties.create()],\n      size: 1,\n      maxSize: properties.maxSize || 1024,\n\n      /**\n       * Get an object from the pool.\n       * @memberof kontra.pool\n       *\n       * @param {object} properties - Properties to pass to object.init().\n       *\n       * @returns {object}\n       */\n      get(properties) {\n        properties = properties || {};\n        // the pool is out of objects if the first object is in use and it can't grow\n        if (this.objects.length == inUse) {\n          if (this.size === this.maxSize) {\n            return;\n          }\n          // double the size of the array by filling it with twice as many objects\n          else {\n            for (let x = 0; x < this.size && this.objects.length < this.maxSize; x++) {\n              this.objects.unshift(this._c());\n            }\n\n            this.size = this.objects.length;\n          }\n        }\n\n        // save off first object in pool to reassign to last object after unshift\n        let obj = this.objects.shift();\n        obj.init(properties);\n        this.objects.push(obj);\n        inUse++;\n        return obj\n      },\n\n      /**\n       * Return all objects that are alive from the pool.\n       * @memberof kontra.pool\n       *\n       * @returns {object[]}\n       */\n      getAliveObjects() {\n        return this.objects.slice(this.objects.length - inUse);\n      },\n\n      /**\n       * Clear the object pool.\n       * @memberof kontra.pool\n       */\n      clear() {\n        inUse = this.objects.length = 0;\n        this.size = 1;\n        this.objects.push(this._c());\n      },\n\n      /**\n       * Update all alive pool objects.\n       * @memberof kontra.pool\n       *\n       * @param {number} dt - Time since last update.\n       */\n      update(dt) {\n        let i = this.size - 1;\n        let obj;\n\n        // If the user kills an object outside of the update cycle, the pool won't know of\n        // the change until the next update and inUse won't be decremented. If the user then\n        // gets an object when inUse is the same size as objects.length, inUse will increment\n        // and this statement will evaluate to -1.\n        //\n        // I don't like having to go through the pool to kill an object as it forces you to\n        // know which object came from which pool. Instead, we'll just prevent the index from\n        // going below 0 and accept the fact that inUse may be out of sync for a frame.\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        // only iterate over the objects that are alive\n        while (i >= index) {\n          obj = this.objects[i];\n\n          obj.update(dt);\n\n          // if the object is dead, move it to the front of the pool\n          if (!obj.isAlive()) {\n            this.objects = this.objects.splice(i, 1).concat(this.objects);\n            inUse--;\n            index++;\n          }\n          else {\n            i--;\n          }\n        }\n      },\n\n      /**\n       * render all alive pool objects.\n       * @memberof kontra.pool\n       */\n      render() {\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        for (let i = this.size - 1; i >= index; i--) {\n          this.objects[i].render();\n        }\n      }\n    };\n  };\n})();\n\n(function() {\n\n  /**\n   * A quadtree for 2D collision checking. The quadtree acts like an object pool in that it\n   * will create subnodes as objects are needed but it won't clean up the subnodes when it\n   * collapses to avoid garbage collection.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the quadtree.\n   * @param {number} [properties.maxDepth=3] - Maximum node depths the quadtree can have.\n   * @param {number} [properties.maxObjects=25] - Maximum number of objects a node can support before splitting.\n   * @param {object} [properties.bounds] - The 2D space this node occupies.\n   * @param {object} [properties.parent] - Private. The node that contains this node.\n   * @param {number} [properties.depth=0] - Private. Current node depth.\n   *\n   * The quadrant indices are numbered as follows (following a z-order curve):\n   *     |\n   *  0  |  1\n   * ----+----\n   *  2  |  3\n   *     |\n   */\n  kontra.quadtree = function(properties) {\n    properties = properties || {};\n\n    return {\n      maxDepth: properties.maxDepth || 3,\n      maxObjects: properties.maxObjects || 25,\n\n      // since we won't clean up any subnodes, we need to keep track of which nodes are\n      // currently the leaf node so we know which nodes to add objects to\n      // b = branch, d = depth, p = parent\n      _b: false,\n      _d: properties.depth || 0,\n      /* @if VISUAL_DEBUG */\n      _p: properties.parent,\n      /* @endif */\n\n      bounds: properties.bounds || {\n        x: 0,\n        y: 0,\n        width: kontra.canvas.width,\n        height: kontra.canvas.height\n      },\n\n      objects: [],\n      subnodes: [],\n\n      /**\n       * Clear the quadtree\n       * @memberof kontra.quadtree\n       */\n      clear() {\n        this.subnodes.map(function(subnode) {\n          subnode.clear();\n        });\n\n        this._b = false;\n        this.objects.length = 0;\n      },\n\n      /**\n       * Find the leaf node the object belongs to and get all objects that are part of\n       * that node.\n       * @memberof kontra.quadtree\n       *\n       * @param {object} object - Object to use for finding the leaf node.\n       *\n       * @returns {object[]} A list of objects in the same leaf node as the object.\n       */\n      get(object) {\n        let objects = [];\n        let indices, i;\n\n        // traverse the tree until we get to a leaf node\n        while (this.subnodes.length && this._b) {\n          indices = this._g(object);\n\n          for (i = 0; i < indices.length; i++) {\n            objects.push.apply(objects, this.subnodes[ indices[i] ].get(object));\n          }\n\n          return objects;\n        }\n\n        return this.objects;\n      },\n\n      /**\n       * Add an object to the quadtree. Once the number of objects in the node exceeds\n       * the maximum number of objects allowed, it will split and move all objects to their\n       * corresponding subnodes.\n       * @memberof kontra.quadtree\n       *\n       * @param {...object|object[]} Objects to add to the quadtree\n       *\n       * @example\n       * kontra.quadtree().add({id:1}, {id:2}, {id:3});\n       * kontra.quadtree().add([{id:1}, {id:2}], {id:3});\n       */\n      add() {\n        let i, j, object, obj, indices, index;\n\n        for (j = 0; j < arguments.length; j++) {\n          object = arguments[j];\n\n          // add a group of objects separately\n          if (Array.isArray(object)) {\n            this.add.apply(this, object);\n\n            continue;\n          }\n\n          // current node has subnodes, so we need to add this object into a subnode\n          if (this._b) {\n            this._a(object);\n\n            continue;\n          }\n\n          // this node is a leaf node so add the object to it\n          this.objects.push(object);\n\n          // split the node if there are too many objects\n          if (this.objects.length > this.maxObjects && this._d < this.maxDepth) {\n            this._s();\n\n            // move all objects to their corresponding subnodes\n            for (i = 0; (obj = this.objects[i]); i++) {\n              this._a(obj);\n            }\n\n            this.objects.length = 0;\n          }\n        }\n      },\n\n      /**\n       * Add an object to a subnode.\n       * @memberof kontra.quadtree\n       * @private\n       *\n       * @param {object} object - Object to add into a subnode\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _a(object, indices, i) {\n        indices = this._g(object);\n\n        // add the object to all subnodes it intersects\n        for (i = 0; i < indices.length; i++) {\n          this.subnodes[ indices[i] ].add(object);\n        }\n      },\n\n      /**\n       * Determine which subnodes the object intersects with.\n       * @memberof kontra.quadtree\n       * @private\n       *\n       * @param {object} object - Object to check.\n       *\n       * @returns {number[]} List of all subnodes object intersects.\n       */\n      _g(object) {\n        let indices = [];\n\n        let verticalMidpoint = this.bounds.x + this.bounds.width / 2;\n        let horizontalMidpoint = this.bounds.y + this.bounds.height / 2;\n\n        // save off quadrant checks for reuse\n        let intersectsTopQuadrants = object.y < horizontalMidpoint && object.y + object.height >= this.bounds.y;\n        let intersectsBottomQuadrants = object.y + object.height >= horizontalMidpoint && object.y < this.bounds.y + this.bounds.height;\n\n        // object intersects with the left quadrants\n        if (object.x < verticalMidpoint && object.x + object.width >= this.bounds.x) {\n          if (intersectsTopQuadrants) {  // top left\n            indices.push(0);\n          }\n\n          if (intersectsBottomQuadrants) {  // bottom left\n            indices.push(2);\n          }\n        }\n\n        // object intersects with the right quadrants\n        if (object.x + object.width >= verticalMidpoint && object.x < this.bounds.x + this.bounds.width) {  // top right\n          if (intersectsTopQuadrants) {\n            indices.push(1);\n          }\n\n          if (intersectsBottomQuadrants) {  // bottom right\n            indices.push(3);\n          }\n        }\n\n        return indices;\n      },\n\n      /**\n       * Split the node into four subnodes.\n       * @memberof kontra.quadtree\n       * @private\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _s(subWidth, subHeight, i) {\n        this._b = true;\n\n        // only split if we haven't split before\n        if (this.subnodes.length) {\n          return;\n        }\n\n        subWidth = this.bounds.width / 2 | 0;\n        subHeight = this.bounds.height / 2 | 0;\n\n        for (i = 0; i < 4; i++) {\n          this.subnodes[i] = kontra.quadtree({\n            bounds: {\n              x: this.bounds.x + (i % 2 === 1 ? subWidth : 0),  // nodes 1 and 3\n              y: this.bounds.y + (i >= 2 ? subHeight : 0),      // nodes 2 and 3\n              width: subWidth,\n              height: subHeight\n            },\n            depth: this._d+1,\n            maxDepth: this.maxDepth,\n            maxObjects: this.maxObjects,\n            /* @if VISUAL_DEBUG */\n            parent: this\n            /* @endif */\n          });\n        }\n      },\n\n      /**\n       * Draw the quadtree. Useful for visual debugging.\n       * @memberof kontra.quadtree\n       */\n       /* @if VISUAL_DEBUG **\n       render() {\n         // don't draw empty leaf nodes, always draw branch nodes and the first node\n         if (this.objects.length || this._d === 0 ||\n             (this._p && this._p._b)) {\n\n           kontra.context.strokeStyle = 'red';\n           kontra.context.strokeRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n\n           if (this.subnodes.length) {\n             for (let i = 0; i < 4; i++) {\n               this.subnodes[i].render();\n             }\n           }\n         }\n       }\n       /* @endif */\n    };\n  };\n})();\n(function() {\n\n  class Vector {\n    /**\n     * Initialize the vectors x and y position.\n     * @memberof kontra.vector\n     * @private\n     *\n     * @param {number} [x=0] - X coordinate.\n     * @param {number} [y=0] - Y coordinate.\n     *\n     * @returns {vector}\n     */\n    constructor(x, y) {\n      this._x = x || 0;\n      this._y = y || 0;\n    }\n\n    /**\n     * Add a vector to this vector.\n     * @memberof kontra.vector\n     *\n     * @param {vector} vector - Vector to add.\n     * @param {number} dt=1 - Time since last update.\n     */\n    add(vector, dt) {\n      this.x += (vector.x || 0) * (dt || 1);\n      this.y += (vector.y || 0) * (dt || 1);\n    }\n\n    /**\n     * Clamp the vector between two points that form a rectangle.\n     * @memberof kontra.vector\n     *\n     * @param {number} xMin - Min x value.\n     * @param {number} yMin - Min y value.\n     * @param {number} xMax - Max x value.\n     * @param {number} yMax - Max y value.\n     */\n    clamp(xMin, yMin, xMax, yMax) {\n      this._c = true;\n      this._a = xMin;\n      this._b = yMin;\n      this._d = xMax;\n      this._e = yMax;\n    }\n\n    /**\n     * Vector x\n     * @memberof kontra.vector\n     *\n     * @property {number} x\n     */\n    get x() {\n      return this._x;\n    }\n\n    /**\n     * Vector y\n     * @memberof kontra.vector\n     *\n     * @property {number} y\n     */\n    get y() {\n      return this._y;\n    }\n\n    set x(value) {\n      this._x = (this._c ? Math.min( Math.max(this._a, value), this._d ) : value);\n    }\n\n    set y(value) {\n      this._y = (this._c ? Math.min( Math.max(this._b, value), this._e ) : value);\n    }\n  }\n\n  /**\n   * A vector for 2D space.\n   * @memberof kontra\n   *\n   * @param {number} [x=0] - X coordinate.\n   * @param {number} [y=0] - Y coordinate.\n   */\n  kontra.vector = (x, y) => {\n    return new Vector(x, y);\n  };\n  kontra.vector.prototype = Vector.prototype;\n\n\n\n\n\n  class Sprite {\n    /**\n     * Initialize properties on the sprite.\n     * @memberof kontra.sprite\n     *\n     * @param {object} properties - Properties of the sprite.\n     * @param {number} properties.x - X coordinate of the sprite.\n     * @param {number} properties.y - Y coordinate of the sprite.\n     * @param {number} [properties.dx] - Change in X position.\n     * @param {number} [properties.dy] - Change in Y position.\n     * @param {number} [properties.ddx] - Change in X velocity.\n     * @param {number} [properties.ddy] - Change in Y velocity.\n     *\n     * @param {number} [properties.ttl=Infinity] - How may frames the sprite should be alive.\n     * @param {number} [properties.rotation=0] - Rotation in radians of the sprite.\n     * @param {number} [properties.anchor={x:0,y:0}] - The x and y origin of the sprite. {0,0} is the top left corner of the sprite, {1,1} is the bottom right corner.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     *\n     * @param {Image|Canvas} [properties.image] - Image for the sprite.\n     *\n     * @param {object} [properties.animations] - Animations for the sprite instead of an image.\n     *\n     * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\n     * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\n     * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\n     *\n     * @param {function} [properties.update] - Function to use to update the sprite.\n     * @param {function} [properties.render] - Function to use to render the sprite.\n     *\n     * If you need the sprite to live forever, or just need it to stay on screen until you\n     * decide when to kill it, you can set <code>ttl</code> to <code>Infinity</code>.\n     * Just be sure to set <code>ttl</code> to 0 when you want the sprite to die.\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    init(properties, prop, temp, firstAnimation) {\n      properties = properties || {};\n\n      this.position = kontra.vector(properties.x, properties.y);\n      this.velocity = kontra.vector(properties.dx, properties.dy);\n      this.acceleration = kontra.vector(properties.ddx, properties.ddy);\n\n      // defaults\n      this.width = this.height = this.rotation = 0;\n      this.ttl = Infinity;\n      this.anchor = {x: 0, y: 0};\n      this.context = kontra.context;\n\n      // loop through properties before overrides\n      for (prop in properties) {\n        this[prop] = properties[prop];\n      }\n\n      // image sprite\n      if (temp = properties.image) {\n        this.image = temp;\n        this.width = (properties.width !== undefined) ? properties.width : temp.width;\n        this.height = (properties.height !== undefined) ? properties.height : temp.height;\n      }\n\n      return this;\n    }\n\n    // define getter and setter shortcut functions to make it easier to work with the\n    // position, velocity, and acceleration vectors.\n\n    /**\n     * Sprite position.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} x\n     */\n    get x() {\n      return this.position.x;\n    }\n\n    /**\n     * Sprite position.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} y\n     */\n    get y() {\n      return this.position.y;\n    }\n\n    /**\n     * Sprite velocity.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} dx\n     */\n    get dx() {\n      return this.velocity.x;\n    }\n\n    /**\n     * Sprite velocity.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} dy\n     */\n    get dy() {\n      return this.velocity.y;\n    }\n\n    /**\n     * Sprite acceleration.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddx\n     */\n    get ddx() {\n      return this.acceleration.x;\n    }\n\n    /**\n     * Sprite acceleration.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddy\n     */\n    get ddy() {\n      return this.acceleration.y;\n    }\n\n    get animations() {\n      return this.anims\n    }\n\n    set x(value) {\n      this.position.x = value;\n    }\n    set y(value) {\n      this.position.y = value;\n    }\n    set dx(value) {\n      this.velocity.x = value;\n    }\n    set dy(value) {\n      this.velocity.y = value;\n    }\n    set ddx(value) {\n      this.acceleration.x = value;\n    }\n    set ddy(value) {\n      this.acceleration.y = value;\n    }\n\n    set animations(value) {\n      let prop, firstAnimation\n      this.anims = {}\n\n      // clone each animation so no sprite shares an animation\n      for (prop in value) {\n        this.anims[prop] = value[prop].clone()\n\n        // default the current animation to the first one in the list\n        firstAnimation = firstAnimation || this.anims[prop]\n      }\n\n      this.currentAnimation = firstAnimation\n      this.width = this.width || firstAnimation.width\n      this.height = this.height || firstAnimation.height\n    }\n\n    /**\n     * Determine if the sprite is alive.\n     * @memberof kontra.sprite\n     *\n     * @returns {boolean}\n     */\n    isAlive() {\n      return this.ttl > 0;\n    }\n\n    /**\n     * Simple bounding box collision test.\n     * NOTE: Does not take into account sprite rotation. If you need collision\n     * detection between rotated sprites you will need to implement your own\n     * CollidesWith() function. I suggest looking at the Separate Axis Theorem.\n     * @memberof kontra.sprite\n     *\n     * @param {object} object - Object to check collision against.\n     *\n     * @returns {boolean|null} True if the objects collide, false otherwise.\n     */\n    collidesWith(object) {\n      if (this.rotation || object.rotation) return null;\n\n      // take into account sprite anchors\n      let x = this.x - this.width * this.anchor.x;\n      let y = this.y - this.height * this.anchor.y;\n\n      let objX = object.x;\n      let objY = object.y;\n      if (object.anchor) {\n        objX -= object.width * object.anchor.x;\n        objY -= object.height * object.anchor.y;\n      }\n\n      return x < objX + object.width &&\n             x + this.width > objX &&\n             y < objY + object.height &&\n             y + this.height > objY;\n    }\n\n    /**\n     * Update the sprites velocity and position.\n     * @memberof kontra.sprite\n     * @abstract\n     *\n     * @param {number} dt - Time since last update.\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the update step. Just call <code>this.advance()</code> when you need\n     * the sprite to update its position.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   update: function update(dt) {\n     *     // do some logic\n     *\n     *     this.advance(dt);\n     *   }\n     * });\n     */\n    update(dt) {\n      this.advance(dt);\n    }\n\n    /**\n     * Render the sprite.\n     * @memberof kontra.sprite.\n     * @abstract\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the render step. Just call <code>this.draw()</code> when you need the\n     * sprite to draw its image.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   render: function render() {\n     *     // do some logic\n     *\n     *     this.draw();\n     *   }\n     * });\n     */\n    render() {\n      this.draw();\n    }\n\n    /**\n     * Play an animation.\n     * @memberof kontra.sprite\n     *\n     * @param {string} name - Name of the animation to play.\n     */\n    playAnimation(name) {\n      this.currentAnimation = this.animations[name];\n\n      if (!this.currentAnimation.loop) {\n        this.currentAnimation.reset();\n      }\n    }\n\n    /**\n     * Advance the sprites position, velocity, and current animation (if it\n     * has one).\n     * @memberof kontra.sprite\n     *\n     * @param {number} dt - Time since last update.\n     */\n    advance(dt) {\n      this.velocity.add(this.acceleration, dt);\n      this.position.add(this.velocity, dt);\n\n      this.ttl--;\n\n      if (this.currentAnimation) {\n        this.currentAnimation.update(dt);\n      }\n    }\n\n    /**\n     * Draw the sprite to the canvas.\n     * @memberof kontra.sprite\n     */\n    draw() {\n      let anchorWidth = -this.width * this.anchor.x;\n      let anchorHeight = -this.height * this.anchor.y;\n\n      this.context.save();\n      this.context.translate(this.x, this.y);\n\n      if (this.rotation) {\n        this.context.rotate(this.rotation);\n      }\n\n      if (this.image) {\n        this.context.drawImage(\n          this.image,\n          0, 0, this.image.width, this.image.height,\n          anchorWidth, anchorHeight, this.width, this.height\n        );\n      }\n      else if (this.currentAnimation) {\n        this.currentAnimation.render({\n          x: anchorWidth,\n          y: anchorHeight,\n          width: this.width,\n          height: this.height,\n          context: this.context\n        });\n      }\n      else {\n        this.context.fillStyle = this.color;\n        this.context.fillRect(anchorWidth, anchorHeight, this.width, this.height);\n      }\n\n      this.context.restore();\n    }\n  };\n\n  /**\n   * A sprite with a position, velocity, and acceleration.\n   * @memberof kontra\n   * @requires kontra.vector\n   *\n   * @param {object} properties - Properties of the sprite.\n   * @param {number} properties.x - X coordinate of the sprite.\n   * @param {number} properties.y - Y coordinate of the sprite.\n   * @param {number} [properties.dx] - Change in X position.\n   * @param {number} [properties.dy] - Change in Y position.\n   * @param {number} [properties.ddx] - Change in X velocity.\n   * @param {number} [properties.ddy] - Change in Y velocity.\n   *\n   * @param {number} [properties.ttl=Infinity] - How may frames the sprite should be alive.\n   * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n   *\n   * @param {Image|Canvas} [properties.image] - Image for the sprite.\n   *\n   * @param {object} [properties.animations] - Animations for the sprite instead of an image.\n   *\n   * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\n   * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\n   * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\n   *\n   * @param {function} [properties.update] - Function to use to update the sprite.\n   * @param {function} [properties.render] - Function to use to render the sprite.\n   */\n  kontra.sprite = (properties) => {\n    return (new Sprite()).init(properties);\n  };\n  kontra.sprite.prototype = Sprite.prototype;\n})();\n(function() {\n\n  class Animation {\n    /**\n     * Initialize properties on the animation.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {object} properties - Properties of the animation.\n     * @param {object} properties.spriteSheet - Sprite sheet for the animation.\n     * @param {number[]} properties.frames - List of frames of the animation.\n     * @param {number}  properties.frameRate - Number of frames to display in one second.\n     * @param {boolean} [properties.loop=true] - If the animation should loop.\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    constructor(properties, frame) {\n      properties = properties || {};\n\n      this.spriteSheet = properties.spriteSheet;\n      this.frames = properties.frames;\n      this.frameRate = properties.frameRate;\n      this.loop = (properties.loop === undefined ? true : properties.loop);\n\n      frame = properties.spriteSheet.frame;\n      this.width = frame.width;\n      this.height = frame.height;\n      this.margin = frame.margin || 0;\n\n      // f = frame, a = accumulator\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\n     * Clone an animation to be used more than once.\n     * @memberof kontra.animation\n     *\n     * @returns {object}\n     */\n    clone() {\n      return kontra.animation(this);\n    }\n\n    /**\n     * Reset an animation to the first frame.\n     * @memberof kontra.animation\n     */\n    reset() {\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\n     * Update the animation. Used when the animation is not paused or stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {number} [dt=1/60] - Time since last update.\n     */\n    update(dt) {\n\n      // if the animation doesn't loop we stop at the last frame\n      if (!this.loop && this._f == this.frames.length-1) return;\n\n      dt = dt || 1 / 60;\n\n      this._a += dt;\n\n      // update to the next frame if it's time\n      while (this._a * this.frameRate >= 1) {\n        this._f = ++this._f % this.frames.length;\n        this._a -= 1 / this.frameRate;\n      }\n    }\n\n    /**\n     * Draw the current frame. Used when the animation is not stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {object} properties - How to draw the animation.\n     * @param {number} properties.x - X position to draw.\n     * @param {number} properties.y - Y position to draw.\n     * @param {number} properties.width - width of the sprite.\n     * @param {number} properties.height - height of the sprit.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     */\n    render(properties) {\n      properties = properties || {};\n\n      // get the row and col of the frame\n      let row = this.frames[this._f] / this.spriteSheet._f | 0;\n      let col = this.frames[this._f] % this.spriteSheet._f | 0;\n      let width = (properties.width !== undefined) ? properties.width : this.width\n      let height = (properties.height !== undefined) ? properties.height : this.height\n      let context = (properties.context || kontra.context)\n      context.drawImage(\n        this.spriteSheet.image,\n        col * this.width + (col * 2 + 1) * this.margin,\n        row * this.height + (row * 2 + 1) * this.margin,\n        this.width, this.height,\n        properties.x, properties.y,\n        width, height\n      );\n    }\n  }\n\n  /**\n   * Single animation from a sprite sheet.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the animation.\n   * @param {object} properties.spriteSheet - Sprite sheet for the animation.\n   * @param {number[]} properties.frames - List of frames of the animation.\n   * @param {number}  properties.frameRate - Number of frames to display in one second.\n   */\n  kontra.animation = function(properties) {\n    return new Animation(properties);\n  };\n  kontra.animation.prototype = Animation.prototype;\n\n\n\n\n\n  class SpriteSheet {\n    /**\n     * Initialize properties on the spriteSheet.\n     * @memberof kontra\n     * @private\n     *\n     * @param {object} properties - Properties of the sprite sheet.\n     * @param {Image|Canvas} properties.image - Image for the sprite sheet.\n     * @param {number} properties.frameWidth - Width (in px) of each frame.\n     * @param {number} properties.frameHeight - Height (in px) of each frame.\n     * @param {number} properties.frameMargin - Margin (in px) between each frame.\n     * @param {object} properties.animations - Animations to create from the sprite sheet.\n     */\n    constructor(properties) {\n      properties = properties || {};\n\n      // @if DEBUG\n      if (!properties.image) {\n        throw Error('You must provide an Image for the SpriteSheet');\n      }\n      // @endif\n\n      this.animations = {};\n      this.image = properties.image;\n      this.frame = {\n        width: properties.frameWidth,\n        height: properties.frameHeight,\n        margin: properties.frameMargin\n      };\n\n      // f = framesPerRow\n      this._f = properties.image.width / properties.frameWidth | 0;\n\n      this.createAnimations(properties.animations);\n    }\n\n    /**\n     * Create animations from the sprite sheet.\n     * @memberof kontra.spriteSheet\n     *\n     * @param {object} animations - List of named animations to create from the Image.\n     * @param {number|string|number[]|string[]} animations.animationName.frames - A single frame or list of frames for this animation.\n     * @param {number} animations.animationName.frameRate - Number of frames to display in one second.\n     *\n     * @example\n     * let sheet = kontra.spriteSheet({image: img, frameWidth: 16, frameHeight: 16});\n     * sheet.createAnimations({\n     *   idle: {\n     *     frames: 1  // single frame animation\n     *   },\n     *   walk: {\n     *     frames: '2..6',  // ascending consecutive frame animation (frames 2-6, inclusive)\n     *     frameRate: 4\n     *   },\n     *   moonWalk: {\n     *     frames: '6..2',  // descending consecutive frame animation\n     *     frameRate: 4\n     *   },\n     *   jump: {\n     *     frames: [7, 12, 2],  // non-consecutive frame animation\n     *     frameRate: 3,\n     *     loop: false\n     *   },\n     *   attack: {\n     *     frames: ['8..10', 13, '10..8'],  // you can also mix and match, in this case frames [8,9,10,13,10,9,8]\n     *     frameRate: 2,\n     *     loop: false\n     *   }\n     * });\n     */\n    createAnimations(animations) {\n      let animation, frames, frameRate, sequence, name;\n\n      for (name in animations) {\n        animation = animations[name];\n        frames = animation.frames;\n\n        // array that holds the order of the animation\n        sequence = [];\n\n        // @if DEBUG\n        if (frames === undefined) {\n          throw Error('Animation ' + name + ' must provide a frames property');\n        }\n        // @endif\n\n        // add new frames to the end of the array\n        [].concat(frames).map(function(frame) {\n          sequence = sequence.concat(this._p(frame));\n        }, this);\n\n        this.animations[name] = kontra.animation({\n          spriteSheet: this,\n          frames: sequence,\n          frameRate: animation.frameRate,\n          loop: animation.loop\n        });\n      }\n    }\n\n    /**\n     * Parse a string of consecutive frames.\n     * @memberof kontra.spriteSheet\n     * @private\n     *\n     * @param {number|string} frames - Start and end frame.\n     *\n     * @returns {number[]} List of frames.\n     */\n    _p(consecutiveFrames, i) {\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      if (+consecutiveFrames === consecutiveFrames) {\n        return consecutiveFrames;\n      }\n\n      let sequence = [];\n      let frames = consecutiveFrames.split('..');\n\n      // coerce string to number\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      let start = i = +frames[0];\n      let end = +frames[1];\n\n      // ascending frame order\n      if (start < end) {\n        for (; i <= end; i++) {\n          sequence.push(i);\n        }\n      }\n      // descending order\n      else {\n        for (; i >= end; i--) {\n          sequence.push(i);\n        }\n      }\n\n      return sequence;\n    }\n  }\n\n  /**\n   * Create a sprite sheet from an image.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the sprite sheet.\n   * @param {Image|Canvas} properties.image - Image for the sprite sheet.\n   * @param {number} properties.frameWidth - Width (in px) of each frame.\n   * @param {number} properties.frameHeight - Height (in px) of each frame.\n   * @param {number} properties.frameMargin - Margin (in px) between each frame.\n   * @param {object} properties.animations - Animations to create from the sprite sheet.\n   */\n  kontra.spriteSheet = function(properties) {\n    return new SpriteSheet(properties);\n  };\n  kontra.spriteSheet.prototype = SpriteSheet.prototype;\n})();\n/**\n * Object for using localStorage.\n */\nkontra.store = {\n\n  /**\n   * Save an item to localStorage.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name to store the item as.\n   * @param {*} value - Item to store.\n   */\n  set(key, value) {\n    if (value === undefined) {\n      localStorage.removeItem(key);\n    }\n    else {\n      localStorage.setItem(key, JSON.stringify(value));\n    }\n  },\n\n  /**\n   * Retrieve an item from localStorage and convert it back to it's original type.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name of the item.\n   *\n   * @returns {*}\n   */\n  get(key) {\n    let value = localStorage.getItem(key);\n\n    try {\n      value = JSON.parse(value);\n    }\n    catch(e) {}\n\n    return value;\n  }\n};\n(function() {\n  kontra.tileEngine = function(properties) {\n    let mapwidth = properties.width * properties.tilewidth;\n    let mapheight = properties.height * properties.tileheight\n\n    // create an off-screen canvas for pre-rendering the map\n    // @see http://jsperf.com/render-vs-prerender\n    let offscreenCanvas = document.createElement('canvas');\n    let offscreenContext = offscreenCanvas.getContext('2d');\n    offscreenCanvas.width = mapwidth;\n    offscreenCanvas.height = mapheight;\n\n    // map layer names to data\n    let layerMap = {};\n    let layerCanvases = {};\n\n    let tileEngine = Object.assign({\n      mapwidth: mapwidth,\n      mapheight: mapheight,\n      _sx: 0,\n      _sy: 0,\n\n      get sx() {\n        return this._sx;\n      },\n\n      get sy() {\n        return this._sy;\n      },\n\n      // when clipping an image, sx and sy must within the image region, otherwise\n      // Firefox and Safari won't draw it.\n      // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a\n      set sx(value) {\n        this._sx = Math.min( Math.max(0, value), mapwidth - kontra.canvas.width );\n      },\n\n      set sy(value) {\n        this._sy = Math.min( Math.max(0, value), mapheight - kontra.canvas.height );\n      },\n\n      /**\n       * Render the pre-rendered canvas.\n       * @memberof kontra.tileEngine\n       */\n      render() {\n        render(offscreenCanvas);\n      },\n\n      /**\n       * Render a specific layer by name.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer to render.\n       */\n      renderLayer(name) {\n        let canvas = layerCanvases[name];\n        let layer = layerMap[name];\n\n        if (!canvas) {\n          // cache the rendered layer so we can render it again without redrawing\n          // all tiles\n          canvas = document.createElement('canvas');\n          canvas.width = mapwidth;\n          canvas.height = mapheight;\n\n          layerCanvases[name] = canvas;\n          tileEngine._r(layer, canvas.getContext('2d'));\n        }\n\n        render(canvas);\n      },\n\n      /**\n       * Simple bounding box collision test for layer tiles.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer.\n       * @param {object} object - Object to check collision against.\n       * @param {number} object.x - X coordinate of the object.\n       * @param {number} object.y - Y coordinate of the object.\n       * @param {number} object.width - Width of the object.\n       * @param {number} object.height - Height of the object.\n       *\n       * @returns {boolean} True if the object collides with a tile, false otherwise.\n       */\n      layerCollidesWith(name, object) {\n        let row = getRow(object.y);\n        let col = getCol(object.x);\n        let endRow = getRow(object.y + object.height);\n        let endCol = getCol(object.x + object.width);\n\n        let layer = layerMap[name];\n\n        // check all tiles\n        for (let r = row; r <= endRow; r++) {\n          for (let c = col; c <= endCol; c++) {\n            if (layer.data[c + r * this.width]) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      },\n\n      /**\n       * Get the tile from the specified layer at x, y or row, col.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer.\n       * @param {object} position - Position of the tile in either x, y or row, col.\n       * @param {number} position.x - X coordinate of the tile.\n       * @param {number} position.y - Y coordinate of the tile.\n       * @param {number} position.row - Row of the tile.\n       * @param {number} position.col - Col of the tile.\n       *\n       * @returns {number}\n       */\n      tileAtLayer(name, position) {\n        let row = position.row || getRow(position.y);\n        let col = position.col || getCol(position.x);\n\n        if (layerMap[name]) {\n          return layerMap[name].data[col + row * tileEngine.width];\n        }\n\n        return -1;\n      },\n\n      // expose for testing\n      _r: renderLayer,\n\n      // @if DEBUG\n      layerCanvases: layerCanvases\n      // @endif\n    }, properties);\n\n    // resolve linked files (source, image)\n    tileEngine.tilesets.forEach(tileset => {\n      let url = (kontra.assets ? kontra.assets._d.get(properties) : '') || window.location.href;\n\n      if (tileset.source) {\n        // @if DEBUG\n        if (!kontra.assets) {\n          throw Error(`You must use \"kontra.assets\" to resolve tileset.source`);\n        }\n        // @endif\n\n        let source = kontra.assets.data[kontra.assets._u(tileset.source, url)];\n\n        // @if DEBUG\n        if (!source) {\n          throw Error(`You must load the tileset source \"${tileset.source}\" before loading the tileset`);\n        }\n        // @endif\n\n        Object.keys(source).forEach(key => {\n          tileset[key] = source[key];\n        });\n      }\n\n      if (''+tileset.image === tileset.image) {\n        // @if DEBUG\n        if (!kontra.assets) {\n          throw Error(`You must use \"kontra.assets\" to resolve tileset.image`);\n        }\n        // @endif\n\n        let image = kontra.assets.images[kontra.assets._u(tileset.image, url)];\n\n        // @if DEBUG\n        if (!image) {\n          throw Error(`You must load the image \"${tileset.image}\" before loading the tileset`);\n        }\n        // @endif\n\n        tileset.image = image;\n      }\n    });\n\n    /**\n     * Get the row from the y coordinate.\n     * @private\n     *\n     * @param {number} y - Y coordinate.\n     *\n     * @return {number}\n     */\n    function getRow(y) {\n      return (tileEngine.sy + y) / tileEngine.tileheight | 0;\n    }\n\n    /**\n     * Get the col from the x coordinate.\n     * @private\n     *\n     * @param {number} x - X coordinate.\n     *\n     * @return {number}\n     */\n    function getCol(x) {\n      return (tileEngine.sx + x) / tileEngine.tilewidth | 0;\n    }\n\n    /**\n     * Render a layer.\n     * @private\n     *\n     * @param {object} layer - Layer data.\n     * @param {Context} context - Context to draw layer to.\n     */\n    function renderLayer(layer, context) {\n      context.save();\n      context.globalAlpha = layer.opacity;\n\n      layer.data.forEach((tile, index) => {\n\n        // skip empty tiles (0)\n        if (!tile) return;\n\n        // find the tileset the tile belongs to\n        // assume tilesets are ordered by firstgid\n        let tileset;\n        for (let i = tileEngine.tilesets.length-1; i >= 0; i--) {\n          tileset = tileEngine.tilesets[i];\n\n          if (tile / tileset.firstgid >= 1) {\n            break;\n          }\n        }\n\n        let tilewidth = tileset.tilewidth || tileEngine.tilewidth;\n        let tileheight = tileset.tileheight || tileEngine.tileheight;\n        let margin = tileset.margin || 0;\n\n        let image = tileset.image;\n\n        let offset = tile - tileset.firstgid;\n        let cols = tileset.columns ||\n          image.width / (tilewidth + margin) | 0;\n\n        let x = (index % tileEngine.width) * tilewidth;\n        let y = (index / tileEngine.width | 0) * tileheight;\n        let sx = (offset % cols) * (tilewidth + margin);\n        let sy = (offset / cols | 0) * (tileheight + margin);\n\n        context.drawImage(\n          image,\n          sx, sy, tilewidth, tileheight,\n          x, y, tilewidth, tileheight\n        );\n      });\n\n      context.restore();\n    }\n\n    /**\n     * Pre-render the tiles to make drawing fast.\n     * @private\n     */\n    function prerender() {\n      if (tileEngine.layers) {\n        tileEngine.layers.forEach(layer => {\n          layerMap[layer.name] = layer;\n\n          if (layer.visible !== false) {\n            tileEngine._r(layer, offscreenContext);\n          }\n        });\n      }\n    }\n\n    /**\n     * Render a tile engine canvas.\n     * @private\n     *\n     * @param {HTMLCanvasElement} canvas - Tile engine canvas to draw.\n     */\n    function render(canvas) {\n      (tileEngine.context || kontra.context).drawImage(\n        canvas,\n        tileEngine.sx, tileEngine.sy, kontra.canvas.width, kontra.canvas.height,\n        0, 0, kontra.canvas.width, kontra.canvas.height\n      );\n    }\n\n    prerender();\n    return tileEngine;\n  };\n})();\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = kontra;\n\n//# sourceURL=webpack:///./node_modules/kontra/kontra.js?");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n\n//# sourceURL=webpack:///./node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "./src/data/actions.js":
/*!*****************************!*\
  !*** ./src/data/actions.js ***!
  \*****************************/
/*! exports provided: actionTable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"actionTable\", function() { return actionTable; });\n/*\r\nSo since we're in the field state at the moment (this is determined at the top),\r\nwe'll interact with things and expect some sort of feedback whether it be opening\r\ndoors, talking or trigger the battle module.\r\n\r\nSimply put, the type/id of thing interacted with will map back to an action map, which,\r\nfor now will just be in here.\r\n\r\nThis could exist in the global context for events or in battle too.\r\n\r\nBy default the map focuses on the type, but if an ID is given, then it's assumed a special\r\nroute must be used.\r\n*/\n// 'Should' match up to id's of action on entities. These will all come from the same\n// place eventually probably.\nvar actionTable = [{\n  name: 'Open Box',\n  // Meta\n  actionId: 'open-box',\n  // Matched action to perform\n  triggeredByType: 'box',\n  triggeredById: null\n}, {\n  name: 'Save The World',\n  actionId: 'save-the-world',\n  triggeredByType: null,\n  triggeredById: 'box-2'\n}];\n\n//# sourceURL=webpack:///./src/data/actions.js?");

/***/ }),

/***/ "./src/data/areas.js":
/*!***************************!*\
  !*** ./src/data/areas.js ***!
  \***************************/
/*! exports provided: areaTable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"areaTable\", function() { return areaTable; });\nvar areaTable = [{\n  id: 'area-1',\n  entities: [{\n    id: 'player-1',\n    type: 'player',\n    // TODO: Could use some consts here.\n    spriteConfig: {\n      color: 'red',\n      x: 30,\n      y: 30,\n      width: 20,\n      height: 40\n    },\n    stats: {\n      health: {\n        max: 100,\n        min: 0,\n        current: 50\n      }\n    },\n    hitBox: {\n      radius: 1\n    }\n  }, {\n    id: 'box-1',\n    type: 'box',\n    spriteConfig: {\n      color: 'blue',\n      x: 100,\n      y: 50,\n      width: 20,\n      height: 40\n    },\n    stats: {\n      health: {\n        max: 100,\n        min: 0,\n        current: 50\n      }\n    },\n    hitBox: {\n      radius: 1\n    },\n    actions: [{\n      name: 'Open',\n      id: 'open-box',\n      do: [// ... animations, functions, etc\n      ]\n    }]\n  }, {\n    id: 'box-2',\n    type: 'box',\n    spriteConfig: {\n      color: 'green',\n      x: 100,\n      y: 100,\n      width: 20,\n      height: 40\n    },\n    stats: {\n      health: {\n        max: 100,\n        min: 0,\n        current: 50\n      }\n    },\n    hitBox: {\n      radius: 1\n    },\n    actions: [{\n      name: 'Save The World',\n      id: 'save-the-world',\n      do: [// ... animations, functions, etc\n      ]\n    }]\n  }, {\n    id: 'gnoll-1',\n    type: 'hostile',\n    spriteConfig: {\n      color: 'orange',\n      x: 50,\n      y: 100,\n      width: 20,\n      height: 40\n    },\n    stats: {\n      health: {\n        max: 100,\n        min: 0,\n        current: 50\n      }\n    },\n    hitBox: {\n      radius: 1\n    },\n    actions: [// {\n      //     name: 'Save The World',\n      //     id: 'save-the-world',\n      //     do: [\n      //         // ... animations, functions, etc\n      //     ]\n      // }\n    ]\n  }]\n}];\n\n//# sourceURL=webpack:///./src/data/areas.js?");

/***/ }),

/***/ "./src/data/stats.js":
/*!***************************!*\
  !*** ./src/data/stats.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_numberHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/numberHelpers */ \"./src/helpers/numberHelpers.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  status: function status() {\n    var effectiveStatuses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var _currentStatus = null;\n    return {\n      id: \"status\",\n      setStatus: function setStatus(type) {\n        return _currentStatus = effectiveStatuses.find(function (status) {\n          return type === status.type;\n        });\n      },\n      clearStatus: function clearStatus() {\n        return _currentStatus = null;\n      },\n      value: function value() {\n        return _currentStatus ? _currentStatus.type : null;\n      }\n    };\n  },\n  hp: function hp(ceil) {\n    var _current = ceil;\n    var _ceil = ceil;\n    var _min = 0;\n    return {\n      id: \"hp\",\n      value: function value() {\n        return _current;\n      },\n      ceil: function ceil() {\n        return _ceil;\n      },\n      increaseValue: function increaseValue(value) {\n        _current = Object(_helpers_numberHelpers__WEBPACK_IMPORTED_MODULE_0__[\"clamp\"])(_current + value, _min, _ceil);\n      },\n      decreaseValue: function decreaseValue(value) {\n        _current = Object(_helpers_numberHelpers__WEBPACK_IMPORTED_MODULE_0__[\"clamp\"])(_current - value, _min, _ceil);\n      }\n    };\n  }\n});\n\n//# sourceURL=webpack:///./src/data/stats.js?");

/***/ }),

/***/ "./src/data/statuses.js":
/*!******************************!*\
  !*** ./src/data/statuses.js ***!
  \******************************/
/*! exports provided: poison */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"poison\", function() { return poison; });\nvar poison = {\n  type: \"poison\",\n  dmg: 1,\n  ticks: 3\n};\n\n//# sourceURL=webpack:///./src/data/statuses.js?");

/***/ }),

/***/ "./src/entities/entityContainer.js":
/*!*****************************************!*\
  !*** ./src/entities/entityContainer.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\");\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers_vectorHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/vectorHelpers */ \"./src/helpers/vectorHelpers.js\");\n/* harmony import */ var _helpers_stateHelpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/stateHelpers */ \"./src/helpers/stateHelpers.js\");\n/* harmony import */ var _data_stats__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/stats */ \"./src/data/stats.js\");\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (_ref) {\n  var id = _ref.id,\n      type = _ref.type,\n      stats = _ref.stats,\n      _ref$spriteConfig = _ref.spriteConfig,\n      spriteConfig = _ref$spriteConfig === void 0 ? {} : _ref$spriteConfig,\n      _ref$actions = _ref.actions,\n      actions = _ref$actions === void 0 ? [] : _ref$actions,\n      _ref$hitbox = _ref.hitbox,\n      _hitbox = _ref$hitbox === void 0 ? {\n    // TODO: Move this too?\n    radius: 1\n  } : _ref$hitbox,\n      _ref$_kontraSprite = _ref._kontraSprite,\n      _kontraSprite = _ref$_kontraSprite === void 0 ? null : _ref$_kontraSprite;\n\n  /// Internal state\n  console.log(stats);\n\n  var _useState = Object(_helpers_stateHelpers__WEBPACK_IMPORTED_MODULE_2__[\"useState\"])(stats.health),\n      _useState2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_useState, 2),\n      health = _useState2[0],\n      setHealth = _useState2[1];\n\n  var statTable = {\n    health: {\n      get: function get() {\n        return health;\n      },\n      set: function set(v) {\n        return setHealth(v);\n      }\n    }\n  };\n  console.log(statTable); /// Internal methods\n\n  var _modifyStat = function _modifyStat() {};\n\n  var _move = function _move(x, y) {\n    if (!_kontraSprite) return; // Normalize in all 8 directions\n\n    var _normalize = Object(_helpers_vectorHelpers__WEBPACK_IMPORTED_MODULE_1__[\"normalize\"])({\n      x: x,\n      y: y\n    }, 1),\n        nx = _normalize.nx,\n        ny = _normalize.ny; // Use 'ddx' when you need acc (which we don't right now)\n\n\n    _kontraSprite.dx = nx;\n    _kontraSprite.dy = ny;\n\n    _kontraSprite.advance();\n  };\n\n  var _interact = function _interact(actionReq) {\n    if (!_kontraSprite) return;\n    console.log(id, 'received signal to', actionReq);\n    var chosenAction = actions.find(function (_ref2) {\n      var id = _ref2.id;\n      return id === actionReq;\n    });\n\n    if (chosenAction) {\n      console.log('And found an action to match:');\n      console.log(chosenAction);\n    } else {\n      console.log('But no action was found.');\n    }\n  };\n\n  var _update = function _update() {\n    if (!_kontraSprite) return; // Just dealing with player sprite right now, will move later\n\n    _kontraSprite.update(); // Wrap the sprites position when it reaches\n    // the edge of the screen\n\n\n    if (_kontraSprite.x > kontra.canvas.width) {\n      _kontraSprite.x = -_kontraSprite.width;\n    }\n  };\n\n  var _render = function _render() {\n    if (!_kontraSprite) return;\n\n    _kontraSprite.render();\n  }; /// Public properties\n\n\n  return {\n    // Info\n    id: id,\n    type: type,\n    spriteConfig: spriteConfig,\n    getStat: function getStat(key) {\n      return Object.keys(statTable).find(function (k) {\n        return key === k ? statTable[k].get() : null;\n      });\n    },\n    setStat: function setStat(key, value) {\n      return console.log('Modify stats:');\n    },\n    hitbox: function hitbox() {\n      return _hitbox;\n    },\n    // Actions\n    move: function move(_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y;\n      return _move(x, y);\n    },\n    interact: function interact(actionReq) {\n      return _interact(actionReq);\n    },\n    // Kontra methods & info (used to find out where we are in the world visually)\n    setSprite: function setSprite(kSprite) {\n      return _kontraSprite = kSprite;\n    },\n    x: function x() {\n      return _kontraSprite ? _kontraSprite.x : 0;\n    },\n    y: function y() {\n      return _kontraSprite ? _kontraSprite.y : 0;\n    },\n    width: function width() {\n      return _kontraSprite ? _kontraSprite.width : 0;\n    },\n    // TODO: Make use of hitbox, don't rely on sprite.\n    height: function height() {\n      return _kontraSprite ? _kontraSprite.height : 0;\n    },\n    update: function update() {\n      return _update();\n    },\n    render: function render() {\n      return _render();\n    }\n  };\n});\n\n//# sourceURL=webpack:///./src/entities/entityContainer.js?");

/***/ }),

/***/ "./src/helpers/actionHelpers.js":
/*!**************************************!*\
  !*** ./src/helpers/actionHelpers.js ***!
  \**************************************/
/*! exports provided: getAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAction\", function() { return getAction; });\nvar getAction = function getAction(_ref) {\n  var type = _ref.type,\n      id = _ref.id,\n      actionTable = _ref.actionTable;\n  var actionById = actionTable.find(function (_ref2) {\n    var triggeredById = _ref2.triggeredById;\n    return triggeredById === id;\n  });\n\n  if (actionById) {\n    return actionById.actionId;\n  }\n\n  var actionByType = actionTable.find(function (_ref3) {\n    var triggeredByType = _ref3.triggeredByType;\n    return triggeredByType === type;\n  });\n  return actionByType ? actionByType.actionId : null;\n};\n\n//# sourceURL=webpack:///./src/helpers/actionHelpers.js?");

/***/ }),

/***/ "./src/helpers/arrayHelpers.js":
/*!*************************************!*\
  !*** ./src/helpers/arrayHelpers.js ***!
  \*************************************/
/*! exports provided: top, first, forget, snip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"top\", function() { return top; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"first\", function() { return first; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forget\", function() { return forget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"snip\", function() { return snip; });\nvar top = function top(arr) {\n  return arr[arr.length - 1];\n};\nvar first = function first(arr) {\n  return arr[0];\n};\nvar forget = function forget(id, arr) {\n  return arr.filter(function (item) {\n    return item.id !== id;\n  });\n};\nvar snip = function snip(arr) {\n  return arr.splice(-1, 1);\n};\n\n//# sourceURL=webpack:///./src/helpers/arrayHelpers.js?");

/***/ }),

/***/ "./src/helpers/collisionHelpers.js":
/*!*****************************************!*\
  !*** ./src/helpers/collisionHelpers.js ***!
  \*****************************************/
/*! exports provided: isOverlapping */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isOverlapping\", function() { return isOverlapping; });\nvar isOverlapping = function isOverlapping(a, b) {\n  // circle vs. circle collision detection\n  // TODO: Do we not also need height?\n  var dx = a.x - b.x;\n  var dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy) < a.radius + b.width;\n};\n\n//# sourceURL=webpack:///./src/helpers/collisionHelpers.js?");

/***/ }),

/***/ "./src/helpers/numberHelpers.js":
/*!**************************************!*\
  !*** ./src/helpers/numberHelpers.js ***!
  \**************************************/
/*! exports provided: clamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp; });\nvar clamp = function clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n};\n\n//# sourceURL=webpack:///./src/helpers/numberHelpers.js?");

/***/ }),

/***/ "./src/helpers/physicsHelpers.js":
/*!***************************************!*\
  !*** ./src/helpers/physicsHelpers.js ***!
  \***************************************/
/*! exports provided: distance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\nvar distance = function distance(a, b) {\n  var _a = a.x - b.x;\n\n  var _b = a.y - b.y;\n\n  return Math.sqrt(_a * _a + _b * _b);\n};\n\n//# sourceURL=webpack:///./src/helpers/physicsHelpers.js?");

/***/ }),

/***/ "./src/helpers/stateHelpers.js":
/*!*************************************!*\
  !*** ./src/helpers/stateHelpers.js ***!
  \*************************************/
/*! exports provided: useState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useState\", function() { return useState; });\nvar useState = function useState(state) {\n  var setter = function setter(modifiedState) {\n    return state = modifiedState;\n  };\n\n  var getter = function getter() {\n    return state;\n  };\n\n  return [getter, setter];\n};\n\n//# sourceURL=webpack:///./src/helpers/stateHelpers.js?");

/***/ }),

/***/ "./src/helpers/vectorHelpers.js":
/*!**************************************!*\
  !*** ./src/helpers/vectorHelpers.js ***!
  \**************************************/
/*! exports provided: normalize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\nvar normalize = function normalize(point, scale) {\n  var norm = Math.sqrt(point.x * point.x + point.y * point.y);\n\n  if (norm != 0) {\n    // as3 return 0,0 for a point of zero length\n    point.x = scale * point.x / norm;\n    point.y = scale * point.y / norm;\n  }\n\n  return {\n    nx: point.x,\n    ny: point.y\n  };\n};\n\n//# sourceURL=webpack:///./src/helpers/vectorHelpers.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var kontra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kontra */ \"./node_modules/kontra/kontra.js\");\n/* harmony import */ var kontra__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(kontra__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _modules_world_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/world/module */ \"./src/modules/world/module.js\");\n/// Libraries\n\n/* Kontra doesn't support module loading so at present so we're using webpacks export-loader. */\n /// Modules\n\n // Init the kontra engine (MUST happen before you start instancing entities)\n\nvar canvasElement = document.getElementById('canvas');\nkontra__WEBPACK_IMPORTED_MODULE_0___default.a.init(canvasElement); /// EXPECTED: Kontra should be initialised at this point!\n// Load world and pass in game library methods (customise to your needs)\n\nvar world = Object(_modules_world_module__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n  createSpriteMethod: kontra__WEBPACK_IMPORTED_MODULE_0___default.a.sprite,\n  keyPressedHandler: kontra__WEBPACK_IMPORTED_MODULE_0___default.a.keys.pressed,\n  keyBindingMethod: kontra__WEBPACK_IMPORTED_MODULE_0___default.a.keys.bind\n}); // Main loop (expects kontra)\n\nvar loop = kontra__WEBPACK_IMPORTED_MODULE_0___default.a.gameLoop({\n  update: function update() {\n    world.update();\n  },\n  render: function render() {\n    world.render();\n  }\n});\nloop.start();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/input/controllers.js":
/*!**********************************!*\
  !*** ./src/input/controllers.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread */ \"./node_modules/@babel/runtime/helpers/objectSpread.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar _move = function _move(_ref) {\n  var speed = _ref.speed,\n      keyPressedHandler = _ref.keyPressedHandler,\n      right = _ref.right,\n      left = _ref.left,\n      up = _ref.up,\n      down = _ref.down;\n  var dir = 0.1 * speed;\n  return {\n    x: keyPressedHandler(right) ? dir : keyPressedHandler(left) ? -dir : 0,\n    y: keyPressedHandler(down) ? dir : keyPressedHandler(up) ? -dir : 0\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: function init(_ref2) {\n    var _ref2$_disabled = _ref2._disabled,\n        _disabled = _ref2$_disabled === void 0 ? false : _ref2$_disabled,\n        _ref2$bindings = _ref2.bindings,\n        bindings = _ref2$bindings === void 0 ? [] : _ref2$bindings,\n        _ref2$keyPressedHandl = _ref2.keyPressedHandler,\n        keyPressedHandler = _ref2$keyPressedHandl === void 0 ? function (key) {} : _ref2$keyPressedHandl,\n        _ref2$keyMap = _ref2.keyMap,\n        keyMap = _ref2$keyMap === void 0 ? {\n      right: 'right',\n      left: 'left',\n      down: 'down',\n      up: 'up',\n      interact: 'e'\n    } : _ref2$keyMap;\n\n    bindings.map(function (_ref3) {\n      var _ref3$bind = _ref3.bind,\n          bind = _ref3$bind === void 0 ? 'key' : _ref3$bind,\n          _ref3$to = _ref3.to,\n          to = _ref3$to === void 0 ? function () {} : _ref3$to,\n          _ref3$keyBindingMetho = _ref3.keyBindingMethod,\n          keyBindingMethod = _ref3$keyBindingMetho === void 0 ? function () {} : _ref3$keyBindingMetho;\n      return keyBindingMethod(bind, to);\n    });\n    return {\n      enabled: function enabled(state) {\n        return _disabled = state;\n      },\n      move: function move(_ref4) {\n        var speed = _ref4.speed;\n        return !_disabled && _move(_babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0___default()({\n          speed: speed,\n          keyPressedHandler: keyPressedHandler\n        }, keyMap));\n      }\n    };\n  }\n});\n\n//# sourceURL=webpack:///./src/input/controllers.js?");

/***/ }),

/***/ "./src/input/handlers/onPlayerInteracted.js":
/*!**************************************************!*\
  !*** ./src/input/handlers/onPlayerInteracted.js ***!
  \**************************************************/
/*! exports provided: onPlayerInteracted */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onPlayerInteracted\", function() { return onPlayerInteracted; });\n/* harmony import */ var _helpers_collisionHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/collisionHelpers */ \"./src/helpers/collisionHelpers.js\");\n/* harmony import */ var _helpers_physicsHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/physicsHelpers */ \"./src/helpers/physicsHelpers.js\");\n/* harmony import */ var _helpers_actionHelpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/actionHelpers */ \"./src/helpers/actionHelpers.js\");\n/* harmony import */ var _data_actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/actions */ \"./src/data/actions.js\");\n\n\n\n\nvar onPlayerInteracted = function onPlayerInteracted(_ref) {\n  var entities = _ref.entities,\n      player = _ref.player;\n  // player.interact((interestingData) => {\n  //     console.log(interestingData);\n  // });\n  var overlappingWithPlayer = entities.filter(function (entity) {\n    if (entity.type !== 'player') {\n      // Circle vs circle detection (still being tested, needs to use hitboxes really),\n      // at present props are a little confused with each other (x and y specifically).\n      // So that part needs a little re-working.\n      var a = {\n        x: entity.x(),\n        y: entity.y(),\n        width: entity.width(),\n        radius: entity.hitbox().radius\n      };\n      var b = {\n        x: player.x(),\n        y: player.y(),\n        width: player.width(),\n        radius: player.hitbox().radius\n      };\n      return Object(_helpers_collisionHelpers__WEBPACK_IMPORTED_MODULE_0__[\"isOverlapping\"])(a, b);\n    }\n\n    return false;\n  }).sort(function (a, b) {\n    return Object(_helpers_physicsHelpers__WEBPACK_IMPORTED_MODULE_1__[\"distance\"])({\n      x: a.x(),\n      y: a.y()\n    }, {\n      x: player.x(),\n      y: player.y()\n    }) < Object(_helpers_physicsHelpers__WEBPACK_IMPORTED_MODULE_1__[\"distance\"])({\n      x: b.x(),\n      y: b.y()\n    }, {\n      x: player.x(),\n      y: player.y()\n    });\n  }); // With distance check applied also\n\n  if (overlappingWithPlayer.length) {\n    var entity = overlappingWithPlayer[0];\n    var actionReq = Object(_helpers_actionHelpers__WEBPACK_IMPORTED_MODULE_2__[\"getAction\"])({\n      id: entity.id,\n      type: entity.type,\n      actionTable: _data_actions__WEBPACK_IMPORTED_MODULE_3__[\"actionTable\"]\n    });\n    entity.interact(actionReq);\n  } // Useful for enemies\n  // sprites = sprites.filter(sprite => sprite.isAlive());\n\n};\n\n//# sourceURL=webpack:///./src/input/handlers/onPlayerInteracted.js?");

/***/ }),

/***/ "./src/map/mapLoader.js":
/*!******************************!*\
  !*** ./src/map/mapLoader.js ***!
  \******************************/
/*! exports provided: loadArea */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadArea\", function() { return loadArea; });\n/* harmony import */ var _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread */ \"./node_modules/@babel/runtime/helpers/objectSpread.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _entities_entityContainer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../entities/entityContainer */ \"./src/entities/entityContainer.js\");\n\n\nvar loadArea = function loadArea() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    query: '',\n    fromTable: [],\n    createSpriteMethod: function createSpriteMethod(options) {}\n  };\n  console.log('Querying area data for', options.query, 'using table data', options.fromTable); // Initialise the entity containers from data and binds sprite object\n\n  var query = options.query,\n      fromTable = options.fromTable,\n      createSpriteMethod = options.createSpriteMethod;\n  var entities = fromTable.find(function (_ref) {\n    var id = _ref.id;\n    return id === query;\n  }).entities.map(function (entityData) {\n    var id = entityData.id,\n        spriteConfig = entityData.spriteConfig;\n    var container = Object(_entities_entityContainer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(entityData);\n    var newSprite = createSpriteMethod(_babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0___default()({\n      id: id\n    }, spriteConfig));\n    container.setSprite(newSprite);\n    return container;\n  }); // Expose util methods for future queries\n\n  return {\n    getEntities: function getEntities() {\n      return entities;\n    },\n    getEntity: function getEntity(query) {\n      return entities.find(function (entity) {\n        return entity.id === query;\n      });\n    }\n  };\n};\n\n//# sourceURL=webpack:///./src/map/mapLoader.js?");

/***/ }),

/***/ "./src/modules/battle/ai/functions.js":
/*!********************************************!*\
  !*** ./src/modules/battle/ai/functions.js ***!
  \********************************************/
/*! exports provided: doStatLogic */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"doStatLogic\", function() { return doStatLogic; });\n/* harmony import */ var _helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../helpers/arrayHelpers */ \"./src/helpers/arrayHelpers.js\");\n\nvar doStatLogic = function doStatLogic(stats, gambits) {\n  var result = Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"first\"])(gambits.sort(function (a, b) {\n    return a.priority - b.priority;\n  }).filter(function (_ref) {\n    var condition = _ref.condition,\n        statId = _ref.statId;\n    var currentStat = stats.find(function (_ref2) {\n      var id = _ref2.id;\n      return id === statId;\n    });\n    return currentStat && condition(currentStat.value(), currentStat.ceil ? currentStat.ceil() : null);\n  }));\n  return result ? result.stateOnTrue : null;\n};\n\n//# sourceURL=webpack:///./src/modules/battle/ai/functions.js?");

/***/ }),

/***/ "./src/modules/battle/ai/gambits.js":
/*!******************************************!*\
  !*** ./src/modules/battle/ai/gambits.js ***!
  \******************************************/
/*! exports provided: genericGambit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genericGambit\", function() { return genericGambit; });\nvar genericGambit = [{\n  gambitId: \"UseAttack\",\n  // Not critical, but helps identify current gambit\n  statId: \"hp\",\n  // The stat this gambit will monitor for its condition method\n  stateOnTrue: \"onAttack\",\n  // Must match the id of needed state\n  priority: 3,\n  // The closer to '0', the higher the priority (can change)\n  condition: function condition(current, ceil) {\n    return current >= ceil;\n  } // Called by logic parser\n\n}, {\n  gambitId: \"UsePotion\",\n  statId: \"hp\",\n  // Support for multiple stats in future planned : [\"hp\", \"mp\"], etc.\n  stateOnTrue: \"onPotion\",\n  priority: 2,\n  condition: function condition(current, ceil) {\n    return current < ceil;\n  }\n}, {\n  gambitId: \"UseAntidote\",\n  statId: \"status\",\n  stateOnTrue: \"onBreak\",\n  //\"onAntidote\",\n  priority: 1,\n  condition: function condition(currentAilment) {\n    return currentAilment === \"poison\";\n  }\n}];\n\n//# sourceURL=webpack:///./src/modules/battle/ai/gambits.js?");

/***/ }),

/***/ "./src/modules/battle/entities/actor.js":
/*!**********************************************!*\
  !*** ./src/modules/battle/entities/actor.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fsm_normalStateMachine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fsm/normalStateMachine */ \"./src/modules/battle/fsm/normalStateMachine.js\");\n/* harmony import */ var _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../states/stateRegistry */ \"./src/modules/battle/states/stateRegistry.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (id, name, globalFSM) {\n  var getStat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (query) {};\n  var setStat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};\n  var command = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (command) {};\n  var onActorUpdate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function (data) {};\n\n  var _target = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n\n  var internalFSM = Object(_fsm_normalStateMachine__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n  return {\n    name: name,\n    setTarget: function setTarget(target) {\n      console.log(name + \"'s target was set to \" + target.name + '.');\n      _target = target;\n    },\n    update: function update() {\n      return internalFSM.update();\n    },\n    decide: function decide() {\n      console.log(name + ' is deciding what to do...');\n      var onAttack = _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get('onAttack');\n      var attackState = onAttack({\n        ownerId: id,\n        target: _target,\n        name: name\n      });\n      globalFSM.push(attackState);\n    },\n    hit: function hit(_ref) {\n      var damage = _ref.damage,\n          originData = _ref.originData;\n      console.log(name + ' got a hit from ' + originData.name + '.');\n      var onHit = _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get('onHit');\n      var hitState = onHit({\n        ownerId: id,\n        name: name,\n        exitParams: {\n          onExit: function onExit() {\n            // You'd check stats here also.\n            onActorUpdate({\n              hp: hp\n            });\n            console.log(name + ' decided to counter ' + originData.name + '.');\n            var onCounter = _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get('onCounter');\n            var counterState = onCounter({\n              ownerId: id,\n              target: _target,\n              name: name\n            });\n            globalFSM.push(counterState);\n          }\n        }\n      });\n      internalFSM.push(hitState);\n    },\n    counterHit: function counterHit(_ref2) {\n      var damage = _ref2.damage,\n          originData = _ref2.originData;\n      console.log(name + ' got a counter attack hit from ' + originData.name + '.');\n      var onHit = _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get('onHit');\n      var hitState = onHit({\n        ownerId: id,\n        name: name,\n        onExit: function onExit() {\n          // You'd check stats here also.\n          onActorUpdate({\n            hp: hp\n          });\n        }\n      });\n      internalFSM.push(hitState);\n    },\n    currentStateComplete: function currentStateComplete() {\n      return internalFSM.currentStateComplete();\n    },\n    onTurnChanged: function onTurnChanged() {}\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/entities/actor.js?");

/***/ }),

/***/ "./src/modules/battle/entities/aiActor.js":
/*!************************************************!*\
  !*** ./src/modules/battle/entities/aiActor.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fsm_normalStateMachine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fsm/normalStateMachine */ \"./src/modules/battle/fsm/normalStateMachine.js\");\n/* harmony import */ var _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../states/stateRegistry */ \"./src/modules/battle/states/stateRegistry.js\");\n/* harmony import */ var _ai_gambits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ai/gambits */ \"./src/modules/battle/ai/gambits.js\");\n/* harmony import */ var _ai_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ai/functions */ \"./src/modules/battle/ai/functions.js\");\n/* harmony import */ var _data_stats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../data/stats */ \"./src/data/stats.js\");\n/* harmony import */ var _data_statuses__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../data/statuses */ \"./src/data/statuses.js\");\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (id, name, globalFSM) {\n  var onActorUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (data) {};\n  var getStat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (query) {};\n  var setStat = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function () {};\n  var command = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function (command) {};\n\n  var _target = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n\n  // TODO: Ensure you're getting individual instances of stats, it may not\n  // be the case if 'stats' is just being exported as an object.\n  var hp = getStat('health'); // Statuses that this entity are susceptible to a pushed here.\n\n  var susceptibleStatuses = _data_stats__WEBPACK_IMPORTED_MODULE_4__[\"default\"].status([_data_statuses__WEBPACK_IMPORTED_MODULE_5__[\"poison\"]]); // You'd usually set this on hit if the thing has a latent effect on it\n  //susceptibleStatuses.setStatus('poison')\n  // ...\n  // Internal fsm handles all personal actions (animations, etc)\n\n  var internalFSM = Object(_fsm_normalStateMachine__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n  return {\n    name: name,\n    setTarget: function setTarget(target) {\n      console.log(name + \"'s target was set to \" + target.name + '.');\n      _target = target;\n    },\n    update: function update() {\n      return internalFSM.update();\n    },\n    decide: function decide() {\n      // So you can actually swap out different gambits depending on the mode\n      // the entity is in. You could potentially have a gambit that specifies\n      // gambits to use.\n      console.log(name + ' is deciding what to do...');\n      var stateResult = Object(_ai_functions__WEBPACK_IMPORTED_MODULE_3__[\"doStatLogic\"])([hp, susceptibleStatuses], _ai_gambits__WEBPACK_IMPORTED_MODULE_2__[\"genericGambit\"]);\n      var chosenState = _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(stateResult);\n      console.log('Chose state:', stateResult); // Using this methods 'assumes' that all states take the same sort of data.\n\n      globalFSM.push(chosenState({\n        ownerId: id,\n        target: _target,\n        name: name\n      }));\n    },\n    hit: function hit(_ref) {\n      var damage = _ref.damage,\n          originData = _ref.originData;\n      console.log(name + ' got a hit from ' + originData.name + '.');\n      var onHit = _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get('onHit');\n      var hitState = onHit({\n        name: name,\n        ownerId: id,\n        exitParams: {\n          onExit: function onExit() {\n            // You'd check stats here also.\n            onActorUpdate({\n              hp: hp\n            });\n            console.log(name + ' decided to counter ' + originData.name + '.');\n            var onCounter = _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get('onCounter');\n            var counterState = onCounter({\n              ownerId: id,\n              target: _target,\n              name: name\n            });\n            globalFSM.push(counterState);\n          }\n        }\n      });\n      internalFSM.push(hitState);\n    },\n    counterHit: function counterHit(_ref2) {\n      var damage = _ref2.damage,\n          originData = _ref2.originData;\n      console.log(name + ' got a counter attack hit from ' + originData.name + '.');\n      var onHit = _states_stateRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get('onHit');\n      var hitState = onHit({\n        ownerId: id,\n        name: name,\n        onExit: function onExit() {\n          // You'd check stats here also.\n          onActorUpdate({\n            hp: hp\n          });\n        }\n      });\n      internalFSM.push(hitState);\n    },\n    currentStateComplete: function currentStateComplete() {\n      return internalFSM.currentStateComplete();\n    },\n    onTurnChanged: function onTurnChanged() {}\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/entities/aiActor.js?");

/***/ }),

/***/ "./src/modules/battle/fsm/normalStateMachine.js":
/*!******************************************************!*\
  !*** ./src/modules/battle/fsm/normalStateMachine.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../helpers/arrayHelpers */ \"./src/helpers/arrayHelpers.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    onBattleUpdate: function onBattleUpdate(data) {}\n  };\n  var onBattleUpdate = options.onBattleUpdate;\n  var innerState = [];\n  return {\n    update: function update() {\n      if (!innerState.length) return;\n      var s = Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"top\"])(innerState);\n      s.update();\n\n      if (s.isComplete()) {\n        s.exit();\n        innerState = Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"forget\"])(s.id, innerState);\n        onBattleUpdate(innerState);\n      }\n    },\n    push: function push(state) {\n      innerState.push(state);\n      Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"top\"])(innerState).enter();\n      onBattleUpdate(state);\n    },\n    currentStateComplete: function currentStateComplete() {\n      return innerState.length ? Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"top\"])(innerState).hasExited() : true;\n    }\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/fsm/normalStateMachine.js?");

/***/ }),

/***/ "./src/modules/battle/fsm/queueStateMachine.js":
/*!*****************************************************!*\
  !*** ./src/modules/battle/fsm/queueStateMachine.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../helpers/arrayHelpers */ \"./src/helpers/arrayHelpers.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    onBattleUpdate: function onBattleUpdate(data) {}\n  };\n  var onBattleUpdate = options.onBattleUpdate;\n  var innerState = [];\n  return {\n    update: function update() {\n      if (!innerState.length) return;\n      var s = Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"first\"])(innerState);\n      s.update();\n\n      if (s.isComplete()) {\n        s.exit();\n        innerState = Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"forget\"])(s.id, innerState);\n\n        if (innerState.length > 0) {\n          Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"first\"])(innerState).enter();\n        }\n\n        onBattleUpdate(innerState);\n      }\n    },\n    push: function push(state) {\n      innerState.push(state);\n\n      if (innerState.length === 1) {\n        Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"first\"])(innerState).enter();\n      }\n\n      onBattleUpdate(state);\n    },\n    currentStateComplete: function currentStateComplete() {\n      return innerState.length ? Object(_helpers_arrayHelpers__WEBPACK_IMPORTED_MODULE_0__[\"first\"])(innerState).hasExited() : true;\n    }\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/fsm/queueStateMachine.js?");

/***/ }),

/***/ "./src/modules/battle/module.js":
/*!**************************************!*\
  !*** ./src/modules/battle/module.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_turnGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/turnGenerator */ \"./src/modules/battle/utils/turnGenerator.js\");\n/* harmony import */ var _fsm_queueStateMachine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fsm/queueStateMachine */ \"./src/modules/battle/fsm/queueStateMachine.js\");\n/* harmony import */ var _entities_actor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./entities/actor */ \"./src/modules/battle/entities/actor.js\");\n/* harmony import */ var _entities_aiActor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./entities/aiActor */ \"./src/modules/battle/entities/aiActor.js\");\n\n\n\n\n/*\r\n- Should an entity fall during battle, it will happen after theis damage state\r\nhas completed. Therefore we can check the battle conditions to determine if we have a winner.\r\n*/\n\nvar watchBattleUpdate = function watchBattleUpdate(data) {\n  console.log('There was a battle update.');\n  console.log(data);\n};\n\nvar watchActorUpdate = function watchActorUpdate(data) {\n  console.log('There was an actor update.');\n  console.log(data);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (_ref) {\n  var participantData = _ref.participantData,\n      onBattleEnded = _ref.onBattleEnded;\n  console.log('New battle started!');\n  var actorQueueState = Object(_fsm_queueStateMachine__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n    onBattleUpdate: watchBattleUpdate\n  });\n  var actors = participantData.map(function (actorContainer) {\n    var id = actorContainer.id,\n        type = actorContainer.type,\n        getStat = actorContainer.getStat,\n        setStat = actorContainer.setStat,\n        command = actorContainer.command; // TODO: Use consts please.\n\n    return type === 'player' ? Object(_entities_actor__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(id, actorQueueState, watchActorUpdate, getStat, setStat, command) : Object(_entities_aiActor__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(id, actorQueueState, watchActorUpdate, getStat, setStat, command);\n  });\n  var turnIterator = Object(_utils_turnGenerator__WEBPACK_IMPORTED_MODULE_0__[\"createTurnIterator\"])(actors);\n  var requiredComplete = [actorQueueState].concat(actors); // TODO: This should be done automatically / manually, not here\n  // TODO: This is an id, not a name, fix this in battle module\n\n  var actorSam = actors.find(function (_ref2) {\n    var name = _ref2.name;\n    return name === 'player-1';\n  });\n  var actorGnoll = actors.find(function (_ref3) {\n    var name = _ref3.name;\n    return name === 'gnoll-1';\n  });\n  actorSam.setTarget(actorGnoll);\n  actorGnoll.setTarget(actorSam);\n\n  var _update = function _update() {\n    actorQueueState.update();\n    actors.forEach(function (x) {\n      return x.update();\n    });\n\n    if (requiredComplete.every(function (x) {\n      return x.currentStateComplete();\n    })) {\n      var nextTurnTaker = turnIterator.getNextValue();\n      console.log(\"%c\" + nextTurnTaker.name + \"'s turn.\", \"background: #e2e3e5; color: #383d41\");\n      actors.map(function (x) {\n        return x.onTurnChanged();\n      });\n      nextTurnTaker.decide();\n    }\n  };\n\n  return {\n    update: _update\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/module.js?");

/***/ }),

/***/ "./src/modules/battle/states/onAttack.js":
/*!***********************************************!*\
  !*** ./src/modules/battle/states/onAttack.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (_ref) {\n  var ownerId = _ref.ownerId,\n      name = _ref.name,\n      target = _ref.target,\n      exitParams = _ref.exitParams,\n      _ref$_isComplete = _ref._isComplete,\n      _isComplete = _ref$_isComplete === void 0 ? false : _ref$_isComplete,\n      _ref$_exited = _ref._exited,\n      _exited = _ref$_exited === void 0 ? false : _ref$_exited;\n\n  return {\n    id: \"onAttack\",\n    isComplete: function isComplete() {\n      return _isComplete;\n    },\n    hasExited: function hasExited() {\n      return _exited;\n    },\n    enter: function enter() {\n      console.log(\"========== 1 ==========\");\n      console.log(\"%c -> Entered Attack state \" + ownerId, \"background: #fff3cd; color: #856404\");\n      setTimeout(function () {\n        console.log(\"%c --> Simulating a fake strike against => \" + target.name, \"background: #fff3cd; color: #856404\"); // Or we use physics hit detection instead (but this way is deterministic).\n\n        target.hit({\n          damage: 1,\n          originData: {\n            ownerId: ownerId,\n            name: name\n          }\n        });\n      }, 500); // Waits for user input or a conditional choice, etc.\n\n      setTimeout(function () {\n        _isComplete = true;\n        console.log(\"%c <- Attack cycle complete by \" + name, \"background: #fff3cd; color: #856404\");\n      }, 3000);\n    },\n    update: function update() {// ...\n    },\n    exit: function exit() {\n      console.log(\"%c <- Exited Attack State \" + ownerId, \"background: #fff3cd; color: #856404\");\n      _exited = true;\n\n      if (exitParams) {\n        exitParams.onExit();\n      }\n    },\n    fail: function fail(code) {// ...\n    }\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/states/onAttack.js?");

/***/ }),

/***/ "./src/modules/battle/states/onBreak.js":
/*!**********************************************!*\
  !*** ./src/modules/battle/states/onBreak.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (_ref) {\n  var ownerId = _ref.ownerId,\n      name = _ref.name,\n      target = _ref.target,\n      exitParams = _ref.exitParams,\n      _ref$_isComplete = _ref._isComplete,\n      _isComplete = _ref$_isComplete === void 0 ? false : _ref$_isComplete,\n      _ref$_exited = _ref._exited,\n      _exited = _ref$_exited === void 0 ? false : _ref$_exited;\n\n  return {\n    id: \"onBreak\",\n    isComplete: function isComplete() {\n      return _isComplete;\n    },\n    hasExited: function hasExited() {\n      return _exited;\n    },\n    enter: function enter() {\n      console.log(name + \" entered a break state for debug purposes.\");\n    },\n    update: function update() {// ...\n    },\n    exit: function exit() {// ...\n    },\n    fail: function fail(code) {// ...\n    }\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/states/onBreak.js?");

/***/ }),

/***/ "./src/modules/battle/states/onCounter.js":
/*!************************************************!*\
  !*** ./src/modules/battle/states/onCounter.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (_ref) {\n  var ownerId = _ref.ownerId,\n      name = _ref.name,\n      target = _ref.target,\n      exitParams = _ref.exitParams,\n      _ref$_isComplete = _ref._isComplete,\n      _isComplete = _ref$_isComplete === void 0 ? false : _ref$_isComplete,\n      _ref$_exited = _ref._exited,\n      _exited = _ref$_exited === void 0 ? false : _ref$_exited;\n\n  return {\n    id: \"onCounter\",\n    isComplete: function isComplete() {\n      return _isComplete;\n    },\n    hasExited: function hasExited() {\n      return _exited;\n    },\n    enter: function enter() {\n      console.log(\"========== 3 ==========\"); // TODO: Get actor data by ID here perhaps instead of passing it all?\n\n      console.log(\"%c----> Execute Counter State For \" + name, \"background: #cce5ff; color: #004085\");\n      console.log(\"%c----> Attacking \" + \"???\", //target.getName(),\n      \"background: #cce5ff; color: #004085\");\n      target.counterHit({\n        damage: 1,\n        originData: {\n          ownerId: ownerId,\n          name: name\n        }\n      });\n      setTimeout(function () {\n        _isComplete = true;\n      }, 5000);\n    },\n    update: function update() {// ...\n    },\n    exit: function exit() {\n      console.log(\"%cExited Counter State \" + name, \"background: #cce5ff; color: #004085\");\n      _exited = true;\n\n      if (exitParams) {\n        exitParams.onExit();\n      }\n    },\n    fail: function fail(code) {// ...\n    }\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/states/onCounter.js?");

/***/ }),

/***/ "./src/modules/battle/states/onHit.js":
/*!********************************************!*\
  !*** ./src/modules/battle/states/onHit.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (_ref) {\n  var ownerId = _ref.ownerId,\n      name = _ref.name,\n      exitParams = _ref.exitParams,\n      _ref$_isComplete = _ref._isComplete,\n      _isComplete = _ref$_isComplete === void 0 ? false : _ref$_isComplete,\n      _ref$_exited = _ref._exited,\n      _exited = _ref$_exited === void 0 ? false : _ref$_exited;\n\n  return {\n    id: \"onHit\",\n    isComplete: function isComplete() {\n      return _isComplete;\n    },\n    hasExited: function hasExited() {\n      return _exited;\n    },\n    enter: function enter() {\n      console.log(\"========== 2 ==========\");\n      console.log(\"%c -> Entered onDamaged State\" + ownerId, \"background: #f8d7da; color: #721c24\");\n      setTimeout(function () {\n        _isComplete = true;\n        console.log(\"%c -> Finished onDamaged animation!\", \"background: #f8d7da; color: #721c24\");\n      }, 2000);\n    },\n    update: function update() {// ...\n    },\n    exit: function exit() {\n      console.log(\"%c <- Exited onDamaged State\" + ownerId, \"background: #f8d7da; color: #721c24\");\n      _exited = true;\n\n      if (exitParams) {\n        exitParams.onExit();\n      }\n    },\n    fail: function fail(code) {// ...\n    }\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/states/onHit.js?");

/***/ }),

/***/ "./src/modules/battle/states/onNotFound.js":
/*!*************************************************!*\
  !*** ./src/modules/battle/states/onNotFound.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (_ref) {\n  var ownerId = _ref.ownerId,\n      name = _ref.name,\n      target = _ref.target,\n      exitParams = _ref.exitParams,\n      _ref$_isComplete = _ref._isComplete,\n      _isComplete = _ref$_isComplete === void 0 ? false : _ref$_isComplete,\n      _ref$_exited = _ref._exited,\n      _exited = _ref$_exited === void 0 ? false : _ref$_exited;\n\n  return {\n    id: \"onNotFound\",\n    isComplete: function isComplete() {\n      return _isComplete;\n    },\n    hasExited: function hasExited() {\n      return _exited;\n    },\n    enter: function enter() {\n      console.error(name + \" tried to enter a state that doesn't exist.\");\n    },\n    update: function update() {// ...\n    },\n    exit: function exit() {// ...\n    },\n    fail: function fail(code) {// ...\n    }\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/battle/states/onNotFound.js?");

/***/ }),

/***/ "./src/modules/battle/states/stateRegistry.js":
/*!****************************************************!*\
  !*** ./src/modules/battle/states/stateRegistry.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _states_onAttack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../states/onAttack */ \"./src/modules/battle/states/onAttack.js\");\n/* harmony import */ var _states_onHit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../states/onHit */ \"./src/modules/battle/states/onHit.js\");\n/* harmony import */ var _states_onCounter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../states/onCounter */ \"./src/modules/battle/states/onCounter.js\");\n/* harmony import */ var _states_onBreak__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../states/onBreak */ \"./src/modules/battle/states/onBreak.js\");\n/* harmony import */ var _states_onNotFound__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../states/onNotFound */ \"./src/modules/battle/states/onNotFound.js\");\n\n\n\n\n\nvar registry = {\n  onAttack: _states_onAttack__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  onHit: _states_onHit__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  onCounter: _states_onCounter__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  onBreak: _states_onBreak__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n}; // State registry doesn't have to be used, it's just easier when the required\n// state is not determined. But I'm choosing to use it regardless.\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  get: function get(stateKey) {\n    return Object.keys(registry).some(function (k) {\n      return k === stateKey;\n    }) ? registry[stateKey] : _states_onNotFound__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n  }\n});\n\n//# sourceURL=webpack:///./src/modules/battle/states/stateRegistry.js?");

/***/ }),

/***/ "./src/modules/battle/utils/turnGenerator.js":
/*!***************************************************!*\
  !*** ./src/modules/battle/utils/turnGenerator.js ***!
  \***************************************************/
/*! exports provided: createTurnIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTurnIterator\", function() { return createTurnIterator; });\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar generator = function generator(arr) {\n  return (\n    /*#__PURE__*/\n    _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function turnQueue() {\n      var i;\n      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function turnQueue$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              i = 0;\n\n            case 1:\n              if (!(i < arr.length)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 4;\n              return arr[i];\n\n            case 4:\n              i++;\n              _context.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, turnQueue);\n    })\n  );\n};\n\nvar createGenerator = function createGenerator(arr) {\n  return generator(arr)();\n};\n\nvar createTurnIterator = function createTurnIterator(arr) {\n  var g = createGenerator(arr);\n  return {\n    getNextValue: function getNextValue() {\n      var next = g.next();\n\n      if (next.done) {\n        g = createGenerator(arr);\n        return g.next().value;\n      }\n\n      return next.value;\n    }\n  };\n};\n\n//# sourceURL=webpack:///./src/modules/battle/utils/turnGenerator.js?");

/***/ }),

/***/ "./src/modules/world/module.js":
/*!*************************************!*\
  !*** ./src/modules/world/module.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread */ \"./node_modules/@babel/runtime/helpers/objectSpread.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"./node_modules/@babel/runtime/helpers/objectWithoutProperties.js\");\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\");\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _battle_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../battle/module */ \"./src/modules/battle/module.js\");\n/* harmony import */ var _input_handlers_onPlayerInteracted__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../input/handlers/onPlayerInteracted */ \"./src/input/handlers/onPlayerInteracted.js\");\n/* harmony import */ var _input_controllers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../input/controllers */ \"./src/input/controllers.js\");\n/* harmony import */ var _data_areas__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../data/areas */ \"./src/data/areas.js\");\n/* harmony import */ var _map_mapLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../map/mapLoader */ \"./src/map/mapLoader.js\");\n/* harmony import */ var _helpers_stateHelpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../helpers/stateHelpers */ \"./src/helpers/stateHelpers.js\");\n\n\n\n/// Sub Modules\n /// Input\n\n\n /// Map Data\n\n\n /// State\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (_ref) {\n  var createSpriteMethod = _ref.createSpriteMethod,\n      keyPressedHandler = _ref.keyPressedHandler,\n      keyBindingMethod = _ref.keyBindingMethod;\n\n  var _useState = Object(_helpers_stateHelpers__WEBPACK_IMPORTED_MODULE_8__[\"useState\"])(null),\n      _useState2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_useState, 2),\n      currentBattle = _useState2[0],\n      setCurrentBattle = _useState2[1];\n\n  var _useState3 = Object(_helpers_stateHelpers__WEBPACK_IMPORTED_MODULE_8__[\"useState\"])(false),\n      _useState4 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_useState3, 2),\n      isInBattle = _useState4[0],\n      setIsInBattle = _useState4[1];\n\n  var onBattleEnded = function onBattleEnded() {\n    /*\r\n    When battle results tallied, etc\r\n    - Re-enable the movement inputs for player\r\n    */\n    setCurrentBattle(null);\n    setIsInBattle(false);\n  };\n\n  var startBattle = function startBattle(entityContainers) {\n    // Never start a second battle if one is in progress!\n    if (isInBattle()) {\n      return;\n    }\n    /*\r\n    Upon triggering with enemy / scene\r\n    - Show graphical ui for battle\r\n    - Set positions of entities to nearest available battle coords\r\n    */\n    // ... find positions in battle radius (should be able to get these from the area data\n    // and current zone everything's in). Each battle needs a zone, regardless wether it's\n    // programatically done.\n\n\n    var newBattle = Object(_battle_module__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n      participantData: entityContainers.map(function (_ref2) {\n        var interact = _ref2.interact,\n            entityProps = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default()(_ref2, [\"interact\"]);\n\n        console.log(entityProps);\n        return _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0___default()({\n          command: interact\n        }, entityProps);\n      }),\n      onBattleEnded: onBattleEnded\n    });\n    setCurrentBattle(newBattle);\n    setIsInBattle(true);\n  };\n\n  var _loadArea = Object(_map_mapLoader__WEBPACK_IMPORTED_MODULE_7__[\"loadArea\"])({\n    query: 'area-1',\n    fromTable: _data_areas__WEBPACK_IMPORTED_MODULE_6__[\"areaTable\"],\n    createSpriteMethod: createSpriteMethod\n  }),\n      getEntities = _loadArea.getEntities,\n      getEntity = _loadArea.getEntity;\n\n  var entities = getEntities();\n  var player = getEntity('player-1');\n  var hostile = getEntity('gnoll-1');\n  var manualControl = _input_controllers__WEBPACK_IMPORTED_MODULE_5__[\"default\"].init({\n    keyPressedHandler: keyPressedHandler,\n    bindings: [{\n      bind: 'e',\n      to: function to() {\n        Object(_input_handlers_onPlayerInteracted__WEBPACK_IMPORTED_MODULE_4__[\"onPlayerInteracted\"])({\n          entities: entities,\n          player: player\n        });\n      },\n      keyBindingMethod: keyBindingMethod\n    }, // Literally just for testing battle, usually this would be a trigger of some sort in environment.\n    {\n      bind: 'b',\n      to: function to() {\n        startBattle([player, hostile]);\n      },\n      keyBindingMethod: keyBindingMethod\n    }]\n  });\n\n  var _update = function _update() {\n    if (isInBattle()) {\n      var battle = currentBattle();\n      battle.update();\n    } else {\n      var pos = manualControl.move({\n        speed: 10\n      });\n      player.move(pos);\n    } // Kontra note: Update must be called (container is entry point).\n\n\n    entities.forEach(function (entity) {\n      return entity.update();\n    });\n  };\n\n  var _render = function _render() {\n    // Kontra note: Render must be called (container is entry point).\n    entities.forEach(function (entity) {\n      return entity.render();\n    });\n  };\n\n  return {\n    update: _update,\n    render: _render\n  };\n});\n\n//# sourceURL=webpack:///./src/modules/world/module.js?");

/***/ })

/******/ });