/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/iterableToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/nonIterableSpread.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectSpread.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectSpread.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var defineProperty = __webpack_require__(/*! ./defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nmodule.exports = _objectSpread;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/objectSpread.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ \"./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js\");\n\nvar iterableToArray = __webpack_require__(/*! ./iterableToArray */ \"./node_modules/@babel/runtime/helpers/iterableToArray.js\");\n\nvar nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ \"./node_modules/@babel/runtime/helpers/nonIterableSpread.js\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/toConsumableArray.js?");

/***/ }),

/***/ "./node_modules/kontra/kontra.js":
/*!***************************************!*\
  !*** ./node_modules/kontra/kontra.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("kontra = {\n\n  /**\n   * Initialize the canvas.\n   * @memberof kontra\n   *\n   * @param {string|HTMLCanvasElement} canvas - Main canvas ID or Element for the game.\n   */\n  init(canvas) {\n\n    // check if canvas is a string first, an element next, or default to getting\n    // first canvas on page\n    var canvasEl = this.canvas = document.getElementById(canvas) ||\n                                 canvas ||\n                                 document.querySelector('canvas');\n\n    // @if DEBUG\n    if (!canvasEl) {\n      throw Error('You must provide a canvas element for the game');\n    }\n    // @endif\n\n    this.context = canvasEl.getContext('2d');\n    this.context.imageSmoothingEnabled = false;\n    this._init();\n  },\n\n  /**\n   * Noop function.\n   * @see https://stackoverflow.com/questions/21634886/what-is-the-javascript-convention-for-no-operation#comment61796464_33458430\n   * @memberof kontra\n   * @private\n   *\n   * The new operator is required when using sinon.stub to replace with the noop.\n   */\n  _noop: new Function,\n\n  /**\n   * Dispatch event to any part of the code that needs to know when\n   * a new frame has started. Will be filled out in pointer events.\n   * @memberOf kontra\n   * @private\n   */\n  _tick: new Function,\n\n  /**\n   * Dispatch event to any part of the code that needs to know when\n   * kontra has initialized. Will be filled out in pointer events.\n   * @memberOf kontra\n   * @private\n   */\n  _init: new Function\n};\n(function() {\n  let imageRegex = /(jpeg|jpg|gif|png)$/;\n  let audioRegex = /(wav|mp3|ogg|aac)$/;\n  let noRegex = /^no$/;\n  let leadingSlash = /^\\//;\n  let trailingSlash = /\\/$/;\n  let assets;\n\n  // audio playability\n  // @see https://github.com/Modernizr/Modernizr/blob/master/feature-detects/audio.js\n  let audio = new Audio();\n  let canUse = {\n    wav: '',\n    mp3: audio.canPlayType('audio/mpeg;').replace(noRegex,''),\n    ogg: audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(noRegex,''),\n    aac: audio.canPlayType('audio/aac;').replace(noRegex,'')\n  };\n\n  /**\n   * Join a base path and asset path.\n   *\n   * @param {string} base - The asset base path.\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function joinPath(base, url) {\n    return [base.replace(trailingSlash, ''), base ? url.replace(leadingSlash, '') : url]\n      .filter(s => s)\n      .join('/')\n  }\n\n  /**\n   * Get the extension of an asset.\n   *\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function getExtension(url) {\n    return url.split('.').pop();\n  }\n\n  /**\n   * Get the name of an asset.\n   *\n   * @param {string} url - The URL to the asset.\n   *\n   * @returns {string}\n   */\n  function getName(url) {\n    let name = url.replace('.' + getExtension(url), '');\n\n    // remove leading slash if there is no folder in the path\n    // @see https://stackoverflow.com/a/50592629/2124254\n    return name.split('/').length == 2 ? name.replace(leadingSlash, '') : name;\n  }\n\n  /**\n   * Load an Image file. Uses imagePath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string} url - The URL to the Image file.\n   *\n   * @returns {Promise} A deferred promise. Promise resolves with the Image.\n   *\n   * @example\n   * kontra.loadImage('car.png');\n   * kontra.loadImage('autobots/truck.png');\n   */\n  function loadImage(originalUrl, url) {\n    return new Promise(function(resolve, reject) {\n      let image = new Image();\n      url = joinPath(assets.imagePath, originalUrl);\n\n      image.onload = function loadImageOnLoad() {\n        let fullUrl = assets._u(url, window.location.href);\n        assets.images[ getName(originalUrl) ] = assets.images[url] = assets.images[fullUrl] = this;\n        resolve(this);\n      };\n\n      image.onerror = function loadImageOnError() {\n        reject(/* @if DEBUG */ 'Unable to load image ' + /* @endif */ url);\n      };\n\n      image.src = url;\n    });\n  }\n\n  /**\n   * Load an Audio file. Supports loading multiple audio formats which will be resolved by\n   * the browser in the order listed. Uses audioPath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string|string[]} url - The URL to the Audio file.\n   *\n   * @returns {Promise} A deferred promise. Promise resolves with the Audio.\n   *\n   * @example\n   * kontra.loadAudio('sound_effects/laser.mp3');\n   * kontra.loadAudio(['explosion.mp3', 'explosion.m4a', 'explosion.ogg']);\n   */\n  function loadAudio(originalUrl, url, undefined) {\n    return new Promise(function(resolve, reject) {\n\n      // determine which audio format the browser can play\n      originalUrl = [].concat(originalUrl).reduce(function(a, source) {\n        return canUse[ getExtension(source) ] ? source : a\n      }, undefined);\n\n      if (!originalUrl) {\n        reject(/* @if DEBUG */ 'cannot play any of the audio formats provided' + /* @endif */ originalUrl);\n      }\n      else {\n        let audio = new Audio();\n        url = joinPath(assets.audioPath, originalUrl);\n\n        audio.addEventListener('canplay', function loadAudioOnLoad() {\n          let fullUrl = assets._u(url, window.location.href);\n          assets.audio[ getName(originalUrl) ] = assets.audio[url] = assets.audio[fullUrl] = this;\n          resolve(this);\n        });\n\n        audio.onerror = function loadAudioOnError() {\n          reject(/* @if DEBUG */ 'Unable to load audio ' + /* @endif */ url);\n        };\n\n        audio.src = url;\n        audio.load();\n      }\n    });\n  }\n\n  /**\n   * Load a data file (be it text or JSON). Uses dataPath to resolve URL.\n   * @memberOf kontra.assets\n   * @private\n   *\n   * @param {string} url - The URL to the data file.\n   *\n   * @returns {Promise} A deferred promise. Resolves with the data or parsed JSON.\n   *\n   * @example\n   * kontra.loadData('bio.json');\n   * kontra.loadData('dialog.txt');\n   */\n  function loadData(originalUrl, url) {\n    url = joinPath(assets.dataPath, originalUrl);\n\n    return fetch(url).then(function(response) {\n      if (!response.ok) throw response;\n      return response.clone().json().catch(function() { return response.text() })\n    }).then(function(data) {\n      let fullUrl = assets._u(url, window.location.href);\n      if (typeof data === 'object') {\n        assets._d.set(data, fullUrl);\n      }\n\n      assets.data[ getName(originalUrl) ] = assets.data[url] = assets.data[fullUrl] = data;\n      return data;\n    });\n  }\n\n  /**\n   * Object for loading assets.\n   */\n  assets = kontra.assets = {\n    // all assets are stored by name as well as by URL\n    images: {},\n    audio: {},\n    data: {},\n    _d: new WeakMap(),\n    _u(url, base) {\n      return new URL(url, base).href;\n    },\n\n    // base asset path for determining asset URLs\n    imagePath: '',\n    audioPath: '',\n    dataPath: '',\n\n    /**\n     * Load an Image, Audio, or data file.\n     * @memberOf kontra.assets\n     *\n     * @param {string|string[]} - Comma separated list of assets to load.\n     *\n     * @returns {Promise}\n     *\n     * @example\n     * kontra.loadAsset('car.png');\n     * kontra.loadAsset(['explosion.mp3', 'explosion.ogg']);\n     * kontra.loadAsset('bio.json');\n     * kontra.loadAsset('car.png', ['explosion.mp3', 'explosion.ogg'], 'bio.json');\n     */\n    load() {\n      let promises = [];\n      let url, extension, asset, i, promise;\n\n      for (i = 0; (asset = arguments[i]); i++) {\n        url = [].concat(asset)[0];\n\n        extension = getExtension(url);\n        if (extension.match(imageRegex)) {\n          promise = loadImage(asset);\n        }\n        else if (extension.match(audioRegex)) {\n          promise = loadAudio(asset);\n        }\n        else {\n          promise = loadData(asset);\n        }\n\n        promises.push(promise);\n      }\n\n      return Promise.all(promises);\n    },\n\n    // expose properties for testing\n    /* @if DEBUG */\n    _canUse: canUse\n    /* @endif */\n  };\n})();\n(function() {\n\n  /**\n   * Game loop that updates and renders the game every frame.\n   * @memberof kontra\n   *\n   * @param {object}   properties - Properties of the game loop.\n   * @param {number}   [properties.fps=60] - Desired frame rate.\n   * @param {boolean}  [properties.clearCanvas=true] - Clear the canvas every frame.\n   * @param {function} properties.update - Function called to update the game.\n   * @param {function} properties.render - Function called to render the game.\n   */\n  kontra.gameLoop = function(properties) {\n    properties = properties || {};\n\n    // check for required functions\n    // @if DEBUG\n    if ( !(properties.update && properties.render) ) {\n      throw Error('You must provide update() and render() functions');\n    }\n    // @endif\n\n    // animation variables\n    let fps = properties.fps || 60;\n    let accumulator = 0;\n    let delta = 1E3 / fps;  // delta between performance.now timings (in ms)\n    let step = 1 / fps;\n\n    let clear = (properties.clearCanvas === false ?\n                kontra._noop :\n                function clear() {\n                  kontra.context.clearRect(0,0,kontra.canvas.width,kontra.canvas.height);\n                });\n    let last, rAF, now, dt;\n\n    /**\n     * Called every frame of the game loop.\n     */\n    function frame() {\n      rAF = requestAnimationFrame(frame);\n\n      now = performance.now();\n      dt = now - last;\n      last = now;\n\n      // prevent updating the game with a very large dt if the game were to lose focus\n      // and then regain focus later\n      if (dt > 1E3) {\n        return;\n      }\n\n      kontra._tick();\n      accumulator += dt;\n\n      while (accumulator >= delta) {\n        gameLoop.update(step);\n\n        accumulator -= delta;\n      }\n\n      clear();\n      gameLoop.render();\n    }\n\n    // game loop object\n    let gameLoop = {\n      update: properties.update,\n      render: properties.render,\n      isStopped: true,\n\n      /**\n       * Start the game loop.\n       * @memberof kontra.gameLoop\n       */\n      start() {\n        last = performance.now();\n        this.isStopped = false;\n        requestAnimationFrame(frame);\n      },\n\n      /**\n       * Stop the game loop.\n       */\n      stop() {\n        this.isStopped = true;\n        cancelAnimationFrame(rAF);\n      },\n\n      // expose properties for testing\n      // @if DEBUG\n      _frame: frame,\n      set _last(value) {\n        last = value;\n      }\n      // @endif\n    };\n\n    return gameLoop;\n  };\n})();\n(function() {\n  let callbacks = {};\n  let pressedKeys = {};\n\n  let keyMap = {\n    // named keys\n    13: 'enter',\n    27: 'esc',\n    32: 'space',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down'\n  };\n\n  // alpha keys\n  // @see https://stackoverflow.com/a/43095772/2124254\n  for (let i = 0; i < 26; i++) {\n    keyMap[65+i] = (10 + i).toString(36);\n  }\n  // numeric keys\n  for (i = 0; i < 10; i++) {\n    keyMap[48+i] = ''+i;\n  }\n\n  addEventListener('keydown', keydownEventHandler);\n  addEventListener('keyup', keyupEventHandler);\n  addEventListener('blur', blurEventHandler);\n\n  /**\n   * Execute a function that corresponds to a keyboard key.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keydownEventHandler(e) {\n    let key = keyMap[e.which];\n    pressedKeys[key] = true;\n\n    if (callbacks[key]) {\n      callbacks[key](e);\n    }\n  }\n\n  /**\n   * Set the released key to not being pressed.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function keyupEventHandler(e) {\n    pressedKeys[ keyMap[e.which] ] = false;\n  }\n\n  /**\n   * Reset pressed keys.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function blurEventHandler(e) {\n    pressedKeys = {};\n  }\n\n  /**\n   * Object for using the keyboard.\n   */\n  kontra.keys = {\n    map: keyMap,\n\n    /**\n     * Register a function to be called on a key press.\n     * @memberof kontra.keys\n     *\n     * @param {string|string[]} keys - key or keys to bind.\n     */\n    bind(keys, callback) {\n      // smaller than doing `Array.isArray(keys) ? keys : [keys]`\n      [].concat(keys).map(function(key) {\n        callbacks[key] = callback;\n      })\n    },\n\n    /**\n     * Remove the callback function for a key.\n     * @memberof kontra.keys\n     *\n     * @param {string|string[]} keys - key or keys to unbind.\n     */\n    unbind(keys, undefined) {\n      [].concat(keys).map(function(key) {\n        callbacks[key] = undefined;\n      })\n    },\n\n    /**\n     * Returns whether a key is pressed.\n     * @memberof kontra.keys\n     *\n     * @param {string} key - Key to check for press.\n     *\n     * @returns {boolean}\n     */\n    pressed(key) {\n      return !!pressedKeys[key];\n    }\n  };\n})();\n(function() {\n  let pointer;\n\n  // save each object as they are rendered to determine which object\n  // is on top when multiple objects are the target of an event.\n  // we'll always use the last frame's object order so we know\n  // the finalized order of all objects, otherwise an object could ask\n  // if it's being hovered when it's rendered first even if other objects\n  // would block it later in the render order\n  let thisFrameRenderOrder = [];\n  let lastFrameRenderOrder = [];\n\n  let callbacks = {};\n  let trackedObjects = [];\n  let pressedButtons = {};\n\n  let buttonMap = {\n    0: 'left',\n    1: 'middle',\n    2: 'right'\n  };\n\n  /**\n   * Detection collision between a rectangle and a circle.\n   * @see https://yal.cc/rectangle-circle-intersection-test/\n   * @private\n   *\n   * @param {object} object - Object to check collision against.\n   */\n  function circleRectCollision(object) {\n    let x = object.x;\n    let y = object.y;\n    if (object.anchor) {\n      x -= object.width * object.anchor.x;\n      y -= object.height * object.anchor.y;\n    }\n\n    let dx = pointer.x - Math.max(x, Math.min(pointer.x, x + object.width));\n    let dy = pointer.y - Math.max(y, Math.min(pointer.y, y + object.height));\n    return (dx * dx + dy * dy) < (pointer.radius * pointer.radius);\n  }\n\n  /**\n   * Get the first on top object that the pointer collides with.\n   * @private\n   *\n   * @returns {object} First object to collide with the pointer.\n   */\n  function getCurrentObject() {\n\n    // if pointer events are required on the very first frame or without a game loop,\n    // use the current frame order array\n    let frameOrder = (lastFrameRenderOrder.length ? lastFrameRenderOrder : thisFrameRenderOrder);\n    let length = frameOrder.length - 1;\n    let object, collides;\n\n    for (let i = length; i >= 0; i--) {\n      object = frameOrder[i];\n\n      if (object.collidesWithPointer) {\n        collides = object.collidesWithPointer(pointer);\n      }\n      else {\n        collides = circleRectCollision(object);\n      }\n\n      if (collides) {\n        return object;\n      }\n    }\n  }\n\n  /**\n   * Execute the onDown callback for an object.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function pointerDownHandler(e) {\n\n    // touchstart should be treated like a left mouse button\n    let button = e.button !== undefined ? buttonMap[e.button] : 'left';\n    pressedButtons[button] = true;\n    pointerHandler(e, 'onDown');\n  }\n\n  /**\n   * Execute the onUp callback for an object.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function pointerUpHandler(e) {\n    let button = e.button !== undefined ? buttonMap[e.button] : 'left';\n    pressedButtons[button] = false;\n    pointerHandler(e, 'onUp');\n  }\n\n  /**\n   * Track the position of the mouse.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function mouseMoveHandler(e) {\n    pointerHandler(e, 'onOver');\n  }\n\n  /**\n   * Reset pressed buttons.\n   * @private\n   *\n   * @param {Event} e\n   */\n  function blurEventHandler(e) {\n    pressedButtons = {};\n  }\n\n  /**\n   * Find the first object for the event and execute it's callback function\n   * @private\n   *\n   * @param {Event} e\n   * @param {string} event - Which event was called.\n   */\n  function pointerHandler(e, event) {\n    if (!kontra.canvas) return;\n\n    let clientX, clientY;\n\n    if (['touchstart', 'touchmove', 'touchend'].indexOf(e.type) !== -1) {\n      clientX = (e.touches[0] || e.changedTouches[0]).clientX;\n      clientY = (e.touches[0] || e.changedTouches[0]).clientY;\n    } else {\n      clientX = e.clientX;\n      clientY = e.clientY;\n    }\n\n    let ratio = kontra.canvas.height / kontra.canvas.offsetHeight;\n    let rect = kontra.canvas.getBoundingClientRect();\n    let x = (clientX - rect.left) * ratio;\n    let y = (clientY - rect.top) * ratio;\n\n    pointer.x = x;\n    pointer.y = y;\n\n    let object;\n    if (e.target === kontra.canvas) {\n      e.preventDefault();\n      object = getCurrentObject();\n      if (object && object[event]) {\n        object[event](e);\n      }\n    }\n\n    if (callbacks[event]) {\n      callbacks[event](e, object);\n    }\n  }\n\n  /**\n   * Object for using the pointer.\n   */\n  pointer = kontra.pointer = {\n    x: 0,\n    y: 0,\n    radius: 5,  // arbitrary size\n\n    /**\n     * Register object to be tracked by pointer events.\n     * @memberof kontra.pointer\n     *\n     * @param {object|object[]} objects - Object or objects to track.\n     */\n    track(objects) {\n      [].concat(objects).map(function(object) {\n\n        // override the objects render function to keep track of render order\n        if (!object._r) {\n          object._r = object.render;\n\n          object.render = function() {\n            thisFrameRenderOrder.push(this);\n            this._r();\n          };\n\n          trackedObjects.push(object);\n        }\n      });\n    },\n\n    /**\n     * Remove object from being tracked by pointer events.\n     * @memberof kontra.pointer\n     *\n     * @param {object|object[]} objects - Object or objects to stop tracking.\n     */\n    untrack(objects, undefined) {\n      [].concat(objects).map(function(object) {\n\n        // restore original render function to no longer track render order\n        object.render = object._r;\n        object._r = undefined;\n\n        let index = trackedObjects.indexOf(object);\n        if (index !== -1) {\n          trackedObjects.splice(index, 1);\n        }\n      })\n    },\n\n    /**\n     * Returns whether a tracked object is under the pointer.\n     * @memberof kontra.pointer\n     *\n     * @param {object} object - Object to check\n     *\n     * @returns {boolean}\n     */\n    over(object) {\n      if (trackedObjects.indexOf(object) === -1) return false;\n\n      return getCurrentObject() === object;\n    },\n\n    /**\n     * Register a function to be called on pointer down.\n     * @memberof kontra.pointer\n     *\n     * @param {function} callback - Function to execute\n     */\n    onDown(callback) {\n      callbacks.onDown = callback;\n    },\n\n    /**\n     * Register a function to be called on pointer up.\n     * @memberof kontra.pointer\n     *\n     * @param {function} callback - Function to execute\n     */\n    onUp(callback) {\n      callbacks.onUp = callback;\n    },\n\n    /**\n     * Returns whether the button is pressed.\n     * @memberof kontra.pointer\n     *\n     * @param {string} button - Button to check for press.\n     *\n     * @returns {boolean}\n     */\n    pressed(button) {\n      return !!pressedButtons[button]\n    }\n  };\n\n  // reset object render order on every new frame\n  kontra._tick = function() {\n    lastFrameRenderOrder.length = 0;\n\n    thisFrameRenderOrder.map(function(object) {\n      lastFrameRenderOrder.push(object);\n    });\n\n    thisFrameRenderOrder.length = 0;\n  };\n\n  // After the canvas is chosen, add events to it\n  kontra._init = function() {\n    kontra.canvas.addEventListener('mousedown', pointerDownHandler);\n    kontra.canvas.addEventListener('touchstart', pointerDownHandler);\n    kontra.canvas.addEventListener('mouseup', pointerUpHandler);\n    kontra.canvas.addEventListener('touchend', pointerUpHandler);\n    kontra.canvas.addEventListener('blur', blurEventHandler);\n    kontra.canvas.addEventListener('mousemove', mouseMoveHandler);\n    kontra.canvas.addEventListener('touchmove', mouseMoveHandler);\n  }\n})();\n\n(function() {\n\n  /**\n   * Object pool. The pool will grow in size to accommodate as many objects as are needed.\n   * Unused items are at the front of the pool and in use items are at the end of the pool.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the pool.\n   * @param {function} properties.create - Function that returns the object to use in the pool.\n   * @param {number} properties.maxSize - The maximum size that the pool will grow to.\n   */\n  kontra.pool = function(properties) {\n    properties = properties || {};\n\n    let inUse = 0;\n\n    // check for the correct structure of the objects added to pools so we know that the\n    // rest of the pool code will work without errors\n    // @if DEBUG\n    let obj;\n    if (!properties.create ||\n        ( !( obj = properties.create() ) ||\n          !( obj.update && obj.init &&\n             obj.isAlive )\n       )) {\n      throw Error('Must provide create() function which returns an object with init(), update(), and isAlive() functions');\n    }\n    // @endif\n\n    return {\n      _c: properties.create,\n\n      // start the pool with an object\n      objects: [properties.create()],\n      size: 1,\n      maxSize: properties.maxSize || 1024,\n\n      /**\n       * Get an object from the pool.\n       * @memberof kontra.pool\n       *\n       * @param {object} properties - Properties to pass to object.init().\n       *\n       * @returns {object}\n       */\n      get(properties) {\n        properties = properties || {};\n        // the pool is out of objects if the first object is in use and it can't grow\n        if (this.objects.length == inUse) {\n          if (this.size === this.maxSize) {\n            return;\n          }\n          // double the size of the array by filling it with twice as many objects\n          else {\n            for (let x = 0; x < this.size && this.objects.length < this.maxSize; x++) {\n              this.objects.unshift(this._c());\n            }\n\n            this.size = this.objects.length;\n          }\n        }\n\n        // save off first object in pool to reassign to last object after unshift\n        let obj = this.objects.shift();\n        obj.init(properties);\n        this.objects.push(obj);\n        inUse++;\n        return obj\n      },\n\n      /**\n       * Return all objects that are alive from the pool.\n       * @memberof kontra.pool\n       *\n       * @returns {object[]}\n       */\n      getAliveObjects() {\n        return this.objects.slice(this.objects.length - inUse);\n      },\n\n      /**\n       * Clear the object pool.\n       * @memberof kontra.pool\n       */\n      clear() {\n        inUse = this.objects.length = 0;\n        this.size = 1;\n        this.objects.push(this._c());\n      },\n\n      /**\n       * Update all alive pool objects.\n       * @memberof kontra.pool\n       *\n       * @param {number} dt - Time since last update.\n       */\n      update(dt) {\n        let i = this.size - 1;\n        let obj;\n\n        // If the user kills an object outside of the update cycle, the pool won't know of\n        // the change until the next update and inUse won't be decremented. If the user then\n        // gets an object when inUse is the same size as objects.length, inUse will increment\n        // and this statement will evaluate to -1.\n        //\n        // I don't like having to go through the pool to kill an object as it forces you to\n        // know which object came from which pool. Instead, we'll just prevent the index from\n        // going below 0 and accept the fact that inUse may be out of sync for a frame.\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        // only iterate over the objects that are alive\n        while (i >= index) {\n          obj = this.objects[i];\n\n          obj.update(dt);\n\n          // if the object is dead, move it to the front of the pool\n          if (!obj.isAlive()) {\n            this.objects = this.objects.splice(i, 1).concat(this.objects);\n            inUse--;\n            index++;\n          }\n          else {\n            i--;\n          }\n        }\n      },\n\n      /**\n       * render all alive pool objects.\n       * @memberof kontra.pool\n       */\n      render() {\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        for (let i = this.size - 1; i >= index; i--) {\n          this.objects[i].render();\n        }\n      }\n    };\n  };\n})();\n\n(function() {\n\n  /**\n   * A quadtree for 2D collision checking. The quadtree acts like an object pool in that it\n   * will create subnodes as objects are needed but it won't clean up the subnodes when it\n   * collapses to avoid garbage collection.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the quadtree.\n   * @param {number} [properties.maxDepth=3] - Maximum node depths the quadtree can have.\n   * @param {number} [properties.maxObjects=25] - Maximum number of objects a node can support before splitting.\n   * @param {object} [properties.bounds] - The 2D space this node occupies.\n   * @param {object} [properties.parent] - Private. The node that contains this node.\n   * @param {number} [properties.depth=0] - Private. Current node depth.\n   *\n   * The quadrant indices are numbered as follows (following a z-order curve):\n   *     |\n   *  0  |  1\n   * ----+----\n   *  2  |  3\n   *     |\n   */\n  kontra.quadtree = function(properties) {\n    properties = properties || {};\n\n    return {\n      maxDepth: properties.maxDepth || 3,\n      maxObjects: properties.maxObjects || 25,\n\n      // since we won't clean up any subnodes, we need to keep track of which nodes are\n      // currently the leaf node so we know which nodes to add objects to\n      // b = branch, d = depth, p = parent\n      _b: false,\n      _d: properties.depth || 0,\n      /* @if VISUAL_DEBUG */\n      _p: properties.parent,\n      /* @endif */\n\n      bounds: properties.bounds || {\n        x: 0,\n        y: 0,\n        width: kontra.canvas.width,\n        height: kontra.canvas.height\n      },\n\n      objects: [],\n      subnodes: [],\n\n      /**\n       * Clear the quadtree\n       * @memberof kontra.quadtree\n       */\n      clear() {\n        this.subnodes.map(function(subnode) {\n          subnode.clear();\n        });\n\n        this._b = false;\n        this.objects.length = 0;\n      },\n\n      /**\n       * Find the leaf node the object belongs to and get all objects that are part of\n       * that node.\n       * @memberof kontra.quadtree\n       *\n       * @param {object} object - Object to use for finding the leaf node.\n       *\n       * @returns {object[]} A list of objects in the same leaf node as the object.\n       */\n      get(object) {\n        let objects = [];\n        let indices, i;\n\n        // traverse the tree until we get to a leaf node\n        while (this.subnodes.length && this._b) {\n          indices = this._g(object);\n\n          for (i = 0; i < indices.length; i++) {\n            objects.push.apply(objects, this.subnodes[ indices[i] ].get(object));\n          }\n\n          return objects;\n        }\n\n        return this.objects;\n      },\n\n      /**\n       * Add an object to the quadtree. Once the number of objects in the node exceeds\n       * the maximum number of objects allowed, it will split and move all objects to their\n       * corresponding subnodes.\n       * @memberof kontra.quadtree\n       *\n       * @param {...object|object[]} Objects to add to the quadtree\n       *\n       * @example\n       * kontra.quadtree().add({id:1}, {id:2}, {id:3});\n       * kontra.quadtree().add([{id:1}, {id:2}], {id:3});\n       */\n      add() {\n        let i, j, object, obj, indices, index;\n\n        for (j = 0; j < arguments.length; j++) {\n          object = arguments[j];\n\n          // add a group of objects separately\n          if (Array.isArray(object)) {\n            this.add.apply(this, object);\n\n            continue;\n          }\n\n          // current node has subnodes, so we need to add this object into a subnode\n          if (this._b) {\n            this._a(object);\n\n            continue;\n          }\n\n          // this node is a leaf node so add the object to it\n          this.objects.push(object);\n\n          // split the node if there are too many objects\n          if (this.objects.length > this.maxObjects && this._d < this.maxDepth) {\n            this._s();\n\n            // move all objects to their corresponding subnodes\n            for (i = 0; (obj = this.objects[i]); i++) {\n              this._a(obj);\n            }\n\n            this.objects.length = 0;\n          }\n        }\n      },\n\n      /**\n       * Add an object to a subnode.\n       * @memberof kontra.quadtree\n       * @private\n       *\n       * @param {object} object - Object to add into a subnode\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _a(object, indices, i) {\n        indices = this._g(object);\n\n        // add the object to all subnodes it intersects\n        for (i = 0; i < indices.length; i++) {\n          this.subnodes[ indices[i] ].add(object);\n        }\n      },\n\n      /**\n       * Determine which subnodes the object intersects with.\n       * @memberof kontra.quadtree\n       * @private\n       *\n       * @param {object} object - Object to check.\n       *\n       * @returns {number[]} List of all subnodes object intersects.\n       */\n      _g(object) {\n        let indices = [];\n\n        let verticalMidpoint = this.bounds.x + this.bounds.width / 2;\n        let horizontalMidpoint = this.bounds.y + this.bounds.height / 2;\n\n        // save off quadrant checks for reuse\n        let intersectsTopQuadrants = object.y < horizontalMidpoint && object.y + object.height >= this.bounds.y;\n        let intersectsBottomQuadrants = object.y + object.height >= horizontalMidpoint && object.y < this.bounds.y + this.bounds.height;\n\n        // object intersects with the left quadrants\n        if (object.x < verticalMidpoint && object.x + object.width >= this.bounds.x) {\n          if (intersectsTopQuadrants) {  // top left\n            indices.push(0);\n          }\n\n          if (intersectsBottomQuadrants) {  // bottom left\n            indices.push(2);\n          }\n        }\n\n        // object intersects with the right quadrants\n        if (object.x + object.width >= verticalMidpoint && object.x < this.bounds.x + this.bounds.width) {  // top right\n          if (intersectsTopQuadrants) {\n            indices.push(1);\n          }\n\n          if (intersectsBottomQuadrants) {  // bottom right\n            indices.push(3);\n          }\n        }\n\n        return indices;\n      },\n\n      /**\n       * Split the node into four subnodes.\n       * @memberof kontra.quadtree\n       * @private\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _s(subWidth, subHeight, i) {\n        this._b = true;\n\n        // only split if we haven't split before\n        if (this.subnodes.length) {\n          return;\n        }\n\n        subWidth = this.bounds.width / 2 | 0;\n        subHeight = this.bounds.height / 2 | 0;\n\n        for (i = 0; i < 4; i++) {\n          this.subnodes[i] = kontra.quadtree({\n            bounds: {\n              x: this.bounds.x + (i % 2 === 1 ? subWidth : 0),  // nodes 1 and 3\n              y: this.bounds.y + (i >= 2 ? subHeight : 0),      // nodes 2 and 3\n              width: subWidth,\n              height: subHeight\n            },\n            depth: this._d+1,\n            maxDepth: this.maxDepth,\n            maxObjects: this.maxObjects,\n            /* @if VISUAL_DEBUG */\n            parent: this\n            /* @endif */\n          });\n        }\n      },\n\n      /**\n       * Draw the quadtree. Useful for visual debugging.\n       * @memberof kontra.quadtree\n       */\n       /* @if VISUAL_DEBUG **\n       render() {\n         // don't draw empty leaf nodes, always draw branch nodes and the first node\n         if (this.objects.length || this._d === 0 ||\n             (this._p && this._p._b)) {\n\n           kontra.context.strokeStyle = 'red';\n           kontra.context.strokeRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n\n           if (this.subnodes.length) {\n             for (let i = 0; i < 4; i++) {\n               this.subnodes[i].render();\n             }\n           }\n         }\n       }\n       /* @endif */\n    };\n  };\n})();\n(function() {\n\n  class Vector {\n    /**\n     * Initialize the vectors x and y position.\n     * @memberof kontra.vector\n     * @private\n     *\n     * @param {number} [x=0] - X coordinate.\n     * @param {number} [y=0] - Y coordinate.\n     *\n     * @returns {vector}\n     */\n    constructor(x, y) {\n      this._x = x || 0;\n      this._y = y || 0;\n    }\n\n    /**\n     * Add a vector to this vector.\n     * @memberof kontra.vector\n     *\n     * @param {vector} vector - Vector to add.\n     * @param {number} dt=1 - Time since last update.\n     */\n    add(vector, dt) {\n      this.x += (vector.x || 0) * (dt || 1);\n      this.y += (vector.y || 0) * (dt || 1);\n    }\n\n    /**\n     * Clamp the vector between two points that form a rectangle.\n     * @memberof kontra.vector\n     *\n     * @param {number} xMin - Min x value.\n     * @param {number} yMin - Min y value.\n     * @param {number} xMax - Max x value.\n     * @param {number} yMax - Max y value.\n     */\n    clamp(xMin, yMin, xMax, yMax) {\n      this._c = true;\n      this._a = xMin;\n      this._b = yMin;\n      this._d = xMax;\n      this._e = yMax;\n    }\n\n    /**\n     * Vector x\n     * @memberof kontra.vector\n     *\n     * @property {number} x\n     */\n    get x() {\n      return this._x;\n    }\n\n    /**\n     * Vector y\n     * @memberof kontra.vector\n     *\n     * @property {number} y\n     */\n    get y() {\n      return this._y;\n    }\n\n    set x(value) {\n      this._x = (this._c ? Math.min( Math.max(this._a, value), this._d ) : value);\n    }\n\n    set y(value) {\n      this._y = (this._c ? Math.min( Math.max(this._b, value), this._e ) : value);\n    }\n  }\n\n  /**\n   * A vector for 2D space.\n   * @memberof kontra\n   *\n   * @param {number} [x=0] - X coordinate.\n   * @param {number} [y=0] - Y coordinate.\n   */\n  kontra.vector = (x, y) => {\n    return new Vector(x, y);\n  };\n  kontra.vector.prototype = Vector.prototype;\n\n\n\n\n\n  class Sprite {\n    /**\n     * Initialize properties on the sprite.\n     * @memberof kontra.sprite\n     *\n     * @param {object} properties - Properties of the sprite.\n     * @param {number} properties.x - X coordinate of the sprite.\n     * @param {number} properties.y - Y coordinate of the sprite.\n     * @param {number} [properties.dx] - Change in X position.\n     * @param {number} [properties.dy] - Change in Y position.\n     * @param {number} [properties.ddx] - Change in X velocity.\n     * @param {number} [properties.ddy] - Change in Y velocity.\n     *\n     * @param {number} [properties.ttl=Infinity] - How may frames the sprite should be alive.\n     * @param {number} [properties.rotation=0] - Rotation in radians of the sprite.\n     * @param {number} [properties.anchor={x:0,y:0}] - The x and y origin of the sprite. {0,0} is the top left corner of the sprite, {1,1} is the bottom right corner.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     *\n     * @param {Image|Canvas} [properties.image] - Image for the sprite.\n     *\n     * @param {object} [properties.animations] - Animations for the sprite instead of an image.\n     *\n     * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\n     * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\n     * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\n     *\n     * @param {function} [properties.update] - Function to use to update the sprite.\n     * @param {function} [properties.render] - Function to use to render the sprite.\n     *\n     * If you need the sprite to live forever, or just need it to stay on screen until you\n     * decide when to kill it, you can set <code>ttl</code> to <code>Infinity</code>.\n     * Just be sure to set <code>ttl</code> to 0 when you want the sprite to die.\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    init(properties, prop, temp, firstAnimation) {\n      properties = properties || {};\n\n      this.position = kontra.vector(properties.x, properties.y);\n      this.velocity = kontra.vector(properties.dx, properties.dy);\n      this.acceleration = kontra.vector(properties.ddx, properties.ddy);\n\n      // defaults\n      this.width = this.height = this.rotation = 0;\n      this.ttl = Infinity;\n      this.anchor = {x: 0, y: 0};\n      this.context = kontra.context;\n\n      // loop through properties before overrides\n      for (prop in properties) {\n        this[prop] = properties[prop];\n      }\n\n      // image sprite\n      if (temp = properties.image) {\n        this.image = temp;\n        this.width = (properties.width !== undefined) ? properties.width : temp.width;\n        this.height = (properties.height !== undefined) ? properties.height : temp.height;\n      }\n\n      return this;\n    }\n\n    // define getter and setter shortcut functions to make it easier to work with the\n    // position, velocity, and acceleration vectors.\n\n    /**\n     * Sprite position.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} x\n     */\n    get x() {\n      return this.position.x;\n    }\n\n    /**\n     * Sprite position.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} y\n     */\n    get y() {\n      return this.position.y;\n    }\n\n    /**\n     * Sprite velocity.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} dx\n     */\n    get dx() {\n      return this.velocity.x;\n    }\n\n    /**\n     * Sprite velocity.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} dy\n     */\n    get dy() {\n      return this.velocity.y;\n    }\n\n    /**\n     * Sprite acceleration.x\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddx\n     */\n    get ddx() {\n      return this.acceleration.x;\n    }\n\n    /**\n     * Sprite acceleration.y\n     * @memberof kontra.sprite\n     *\n     * @property {number} ddy\n     */\n    get ddy() {\n      return this.acceleration.y;\n    }\n\n    get animations() {\n      return this.anims\n    }\n\n    set x(value) {\n      this.position.x = value;\n    }\n    set y(value) {\n      this.position.y = value;\n    }\n    set dx(value) {\n      this.velocity.x = value;\n    }\n    set dy(value) {\n      this.velocity.y = value;\n    }\n    set ddx(value) {\n      this.acceleration.x = value;\n    }\n    set ddy(value) {\n      this.acceleration.y = value;\n    }\n\n    set animations(value) {\n      let prop, firstAnimation\n      this.anims = {}\n\n      // clone each animation so no sprite shares an animation\n      for (prop in value) {\n        this.anims[prop] = value[prop].clone()\n\n        // default the current animation to the first one in the list\n        firstAnimation = firstAnimation || this.anims[prop]\n      }\n\n      this.currentAnimation = firstAnimation\n      this.width = this.width || firstAnimation.width\n      this.height = this.height || firstAnimation.height\n    }\n\n    /**\n     * Determine if the sprite is alive.\n     * @memberof kontra.sprite\n     *\n     * @returns {boolean}\n     */\n    isAlive() {\n      return this.ttl > 0;\n    }\n\n    /**\n     * Simple bounding box collision test.\n     * NOTE: Does not take into account sprite rotation. If you need collision\n     * detection between rotated sprites you will need to implement your own\n     * CollidesWith() function. I suggest looking at the Separate Axis Theorem.\n     * @memberof kontra.sprite\n     *\n     * @param {object} object - Object to check collision against.\n     *\n     * @returns {boolean|null} True if the objects collide, false otherwise.\n     */\n    collidesWith(object) {\n      if (this.rotation || object.rotation) return null;\n\n      // take into account sprite anchors\n      let x = this.x - this.width * this.anchor.x;\n      let y = this.y - this.height * this.anchor.y;\n\n      let objX = object.x;\n      let objY = object.y;\n      if (object.anchor) {\n        objX -= object.width * object.anchor.x;\n        objY -= object.height * object.anchor.y;\n      }\n\n      return x < objX + object.width &&\n             x + this.width > objX &&\n             y < objY + object.height &&\n             y + this.height > objY;\n    }\n\n    /**\n     * Update the sprites velocity and position.\n     * @memberof kontra.sprite\n     * @abstract\n     *\n     * @param {number} dt - Time since last update.\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the update step. Just call <code>this.advance()</code> when you need\n     * the sprite to update its position.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   update: function update(dt) {\n     *     // do some logic\n     *\n     *     this.advance(dt);\n     *   }\n     * });\n     */\n    update(dt) {\n      this.advance(dt);\n    }\n\n    /**\n     * Render the sprite.\n     * @memberof kontra.sprite.\n     * @abstract\n     *\n     * This function can be overridden on a per sprite basis if more functionality\n     * is needed in the render step. Just call <code>this.draw()</code> when you need the\n     * sprite to draw its image.\n     *\n     * @example\n     * sprite = kontra.sprite({\n     *   render: function render() {\n     *     // do some logic\n     *\n     *     this.draw();\n     *   }\n     * });\n     */\n    render() {\n      this.draw();\n    }\n\n    /**\n     * Play an animation.\n     * @memberof kontra.sprite\n     *\n     * @param {string} name - Name of the animation to play.\n     */\n    playAnimation(name) {\n      this.currentAnimation = this.animations[name];\n\n      if (!this.currentAnimation.loop) {\n        this.currentAnimation.reset();\n      }\n    }\n\n    /**\n     * Advance the sprites position, velocity, and current animation (if it\n     * has one).\n     * @memberof kontra.sprite\n     *\n     * @param {number} dt - Time since last update.\n     */\n    advance(dt) {\n      this.velocity.add(this.acceleration, dt);\n      this.position.add(this.velocity, dt);\n\n      this.ttl--;\n\n      if (this.currentAnimation) {\n        this.currentAnimation.update(dt);\n      }\n    }\n\n    /**\n     * Draw the sprite to the canvas.\n     * @memberof kontra.sprite\n     */\n    draw() {\n      let anchorWidth = -this.width * this.anchor.x;\n      let anchorHeight = -this.height * this.anchor.y;\n\n      this.context.save();\n      this.context.translate(this.x, this.y);\n\n      if (this.rotation) {\n        this.context.rotate(this.rotation);\n      }\n\n      if (this.image) {\n        this.context.drawImage(\n          this.image,\n          0, 0, this.image.width, this.image.height,\n          anchorWidth, anchorHeight, this.width, this.height\n        );\n      }\n      else if (this.currentAnimation) {\n        this.currentAnimation.render({\n          x: anchorWidth,\n          y: anchorHeight,\n          width: this.width,\n          height: this.height,\n          context: this.context\n        });\n      }\n      else {\n        this.context.fillStyle = this.color;\n        this.context.fillRect(anchorWidth, anchorHeight, this.width, this.height);\n      }\n\n      this.context.restore();\n    }\n  };\n\n  /**\n   * A sprite with a position, velocity, and acceleration.\n   * @memberof kontra\n   * @requires kontra.vector\n   *\n   * @param {object} properties - Properties of the sprite.\n   * @param {number} properties.x - X coordinate of the sprite.\n   * @param {number} properties.y - Y coordinate of the sprite.\n   * @param {number} [properties.dx] - Change in X position.\n   * @param {number} [properties.dy] - Change in Y position.\n   * @param {number} [properties.ddx] - Change in X velocity.\n   * @param {number} [properties.ddy] - Change in Y velocity.\n   *\n   * @param {number} [properties.ttl=Infinity] - How may frames the sprite should be alive.\n   * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n   *\n   * @param {Image|Canvas} [properties.image] - Image for the sprite.\n   *\n   * @param {object} [properties.animations] - Animations for the sprite instead of an image.\n   *\n   * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\n   * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\n   * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\n   *\n   * @param {function} [properties.update] - Function to use to update the sprite.\n   * @param {function} [properties.render] - Function to use to render the sprite.\n   */\n  kontra.sprite = (properties) => {\n    return (new Sprite()).init(properties);\n  };\n  kontra.sprite.prototype = Sprite.prototype;\n})();\n(function() {\n\n  class Animation {\n    /**\n     * Initialize properties on the animation.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {object} properties - Properties of the animation.\n     * @param {object} properties.spriteSheet - Sprite sheet for the animation.\n     * @param {number[]} properties.frames - List of frames of the animation.\n     * @param {number}  properties.frameRate - Number of frames to display in one second.\n     * @param {boolean} [properties.loop=true] - If the animation should loop.\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    constructor(properties, frame) {\n      properties = properties || {};\n\n      this.spriteSheet = properties.spriteSheet;\n      this.frames = properties.frames;\n      this.frameRate = properties.frameRate;\n      this.loop = (properties.loop === undefined ? true : properties.loop);\n\n      frame = properties.spriteSheet.frame;\n      this.width = frame.width;\n      this.height = frame.height;\n      this.margin = frame.margin || 0;\n\n      // f = frame, a = accumulator\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\n     * Clone an animation to be used more than once.\n     * @memberof kontra.animation\n     *\n     * @returns {object}\n     */\n    clone() {\n      return kontra.animation(this);\n    }\n\n    /**\n     * Reset an animation to the first frame.\n     * @memberof kontra.animation\n     */\n    reset() {\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\n     * Update the animation. Used when the animation is not paused or stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {number} [dt=1/60] - Time since last update.\n     */\n    update(dt) {\n\n      // if the animation doesn't loop we stop at the last frame\n      if (!this.loop && this._f == this.frames.length-1) return;\n\n      dt = dt || 1 / 60;\n\n      this._a += dt;\n\n      // update to the next frame if it's time\n      while (this._a * this.frameRate >= 1) {\n        this._f = ++this._f % this.frames.length;\n        this._a -= 1 / this.frameRate;\n      }\n    }\n\n    /**\n     * Draw the current frame. Used when the animation is not stopped.\n     * @memberof kontra.animation\n     * @private\n     *\n     * @param {object} properties - How to draw the animation.\n     * @param {number} properties.x - X position to draw.\n     * @param {number} properties.y - Y position to draw.\n     * @param {number} properties.width - width of the sprite.\n     * @param {number} properties.height - height of the sprit.\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\n     */\n    render(properties) {\n      properties = properties || {};\n\n      // get the row and col of the frame\n      let row = this.frames[this._f] / this.spriteSheet._f | 0;\n      let col = this.frames[this._f] % this.spriteSheet._f | 0;\n      let width = (properties.width !== undefined) ? properties.width : this.width\n      let height = (properties.height !== undefined) ? properties.height : this.height\n      let context = (properties.context || kontra.context)\n      context.drawImage(\n        this.spriteSheet.image,\n        col * this.width + (col * 2 + 1) * this.margin,\n        row * this.height + (row * 2 + 1) * this.margin,\n        this.width, this.height,\n        properties.x, properties.y,\n        width, height\n      );\n    }\n  }\n\n  /**\n   * Single animation from a sprite sheet.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the animation.\n   * @param {object} properties.spriteSheet - Sprite sheet for the animation.\n   * @param {number[]} properties.frames - List of frames of the animation.\n   * @param {number}  properties.frameRate - Number of frames to display in one second.\n   */\n  kontra.animation = function(properties) {\n    return new Animation(properties);\n  };\n  kontra.animation.prototype = Animation.prototype;\n\n\n\n\n\n  class SpriteSheet {\n    /**\n     * Initialize properties on the spriteSheet.\n     * @memberof kontra\n     * @private\n     *\n     * @param {object} properties - Properties of the sprite sheet.\n     * @param {Image|Canvas} properties.image - Image for the sprite sheet.\n     * @param {number} properties.frameWidth - Width (in px) of each frame.\n     * @param {number} properties.frameHeight - Height (in px) of each frame.\n     * @param {number} properties.frameMargin - Margin (in px) between each frame.\n     * @param {object} properties.animations - Animations to create from the sprite sheet.\n     */\n    constructor(properties) {\n      properties = properties || {};\n\n      // @if DEBUG\n      if (!properties.image) {\n        throw Error('You must provide an Image for the SpriteSheet');\n      }\n      // @endif\n\n      this.animations = {};\n      this.image = properties.image;\n      this.frame = {\n        width: properties.frameWidth,\n        height: properties.frameHeight,\n        margin: properties.frameMargin\n      };\n\n      // f = framesPerRow\n      this._f = properties.image.width / properties.frameWidth | 0;\n\n      this.createAnimations(properties.animations);\n    }\n\n    /**\n     * Create animations from the sprite sheet.\n     * @memberof kontra.spriteSheet\n     *\n     * @param {object} animations - List of named animations to create from the Image.\n     * @param {number|string|number[]|string[]} animations.animationName.frames - A single frame or list of frames for this animation.\n     * @param {number} animations.animationName.frameRate - Number of frames to display in one second.\n     *\n     * @example\n     * let sheet = kontra.spriteSheet({image: img, frameWidth: 16, frameHeight: 16});\n     * sheet.createAnimations({\n     *   idle: {\n     *     frames: 1  // single frame animation\n     *   },\n     *   walk: {\n     *     frames: '2..6',  // ascending consecutive frame animation (frames 2-6, inclusive)\n     *     frameRate: 4\n     *   },\n     *   moonWalk: {\n     *     frames: '6..2',  // descending consecutive frame animation\n     *     frameRate: 4\n     *   },\n     *   jump: {\n     *     frames: [7, 12, 2],  // non-consecutive frame animation\n     *     frameRate: 3,\n     *     loop: false\n     *   },\n     *   attack: {\n     *     frames: ['8..10', 13, '10..8'],  // you can also mix and match, in this case frames [8,9,10,13,10,9,8]\n     *     frameRate: 2,\n     *     loop: false\n     *   }\n     * });\n     */\n    createAnimations(animations) {\n      let animation, frames, frameRate, sequence, name;\n\n      for (name in animations) {\n        animation = animations[name];\n        frames = animation.frames;\n\n        // array that holds the order of the animation\n        sequence = [];\n\n        // @if DEBUG\n        if (frames === undefined) {\n          throw Error('Animation ' + name + ' must provide a frames property');\n        }\n        // @endif\n\n        // add new frames to the end of the array\n        [].concat(frames).map(function(frame) {\n          sequence = sequence.concat(this._p(frame));\n        }, this);\n\n        this.animations[name] = kontra.animation({\n          spriteSheet: this,\n          frames: sequence,\n          frameRate: animation.frameRate,\n          loop: animation.loop\n        });\n      }\n    }\n\n    /**\n     * Parse a string of consecutive frames.\n     * @memberof kontra.spriteSheet\n     * @private\n     *\n     * @param {number|string} frames - Start and end frame.\n     *\n     * @returns {number[]} List of frames.\n     */\n    _p(consecutiveFrames, i) {\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      if (+consecutiveFrames === consecutiveFrames) {\n        return consecutiveFrames;\n      }\n\n      let sequence = [];\n      let frames = consecutiveFrames.split('..');\n\n      // coerce string to number\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      let start = i = +frames[0];\n      let end = +frames[1];\n\n      // ascending frame order\n      if (start < end) {\n        for (; i <= end; i++) {\n          sequence.push(i);\n        }\n      }\n      // descending order\n      else {\n        for (; i >= end; i--) {\n          sequence.push(i);\n        }\n      }\n\n      return sequence;\n    }\n  }\n\n  /**\n   * Create a sprite sheet from an image.\n   * @memberof kontra\n   *\n   * @param {object} properties - Properties of the sprite sheet.\n   * @param {Image|Canvas} properties.image - Image for the sprite sheet.\n   * @param {number} properties.frameWidth - Width (in px) of each frame.\n   * @param {number} properties.frameHeight - Height (in px) of each frame.\n   * @param {number} properties.frameMargin - Margin (in px) between each frame.\n   * @param {object} properties.animations - Animations to create from the sprite sheet.\n   */\n  kontra.spriteSheet = function(properties) {\n    return new SpriteSheet(properties);\n  };\n  kontra.spriteSheet.prototype = SpriteSheet.prototype;\n})();\n/**\n * Object for using localStorage.\n */\nkontra.store = {\n\n  /**\n   * Save an item to localStorage.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name to store the item as.\n   * @param {*} value - Item to store.\n   */\n  set(key, value) {\n    if (value === undefined) {\n      localStorage.removeItem(key);\n    }\n    else {\n      localStorage.setItem(key, JSON.stringify(value));\n    }\n  },\n\n  /**\n   * Retrieve an item from localStorage and convert it back to it's original type.\n   * @memberof kontra.store\n   *\n   * @param {string} key - Name of the item.\n   *\n   * @returns {*}\n   */\n  get(key) {\n    let value = localStorage.getItem(key);\n\n    try {\n      value = JSON.parse(value);\n    }\n    catch(e) {}\n\n    return value;\n  }\n};\n(function() {\n  kontra.tileEngine = function(properties) {\n    let mapwidth = properties.width * properties.tilewidth;\n    let mapheight = properties.height * properties.tileheight\n\n    // create an off-screen canvas for pre-rendering the map\n    // @see http://jsperf.com/render-vs-prerender\n    let offscreenCanvas = document.createElement('canvas');\n    let offscreenContext = offscreenCanvas.getContext('2d');\n    offscreenCanvas.width = mapwidth;\n    offscreenCanvas.height = mapheight;\n\n    // map layer names to data\n    let layerMap = {};\n    let layerCanvases = {};\n\n    let tileEngine = Object.assign({\n      mapwidth: mapwidth,\n      mapheight: mapheight,\n      _sx: 0,\n      _sy: 0,\n\n      get sx() {\n        return this._sx;\n      },\n\n      get sy() {\n        return this._sy;\n      },\n\n      // when clipping an image, sx and sy must within the image region, otherwise\n      // Firefox and Safari won't draw it.\n      // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a\n      set sx(value) {\n        this._sx = Math.min( Math.max(0, value), mapwidth - kontra.canvas.width );\n      },\n\n      set sy(value) {\n        this._sy = Math.min( Math.max(0, value), mapheight - kontra.canvas.height );\n      },\n\n      /**\n       * Render the pre-rendered canvas.\n       * @memberof kontra.tileEngine\n       */\n      render() {\n        render(offscreenCanvas);\n      },\n\n      /**\n       * Render a specific layer by name.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer to render.\n       */\n      renderLayer(name) {\n        let canvas = layerCanvases[name];\n        let layer = layerMap[name];\n\n        if (!canvas) {\n          // cache the rendered layer so we can render it again without redrawing\n          // all tiles\n          canvas = document.createElement('canvas');\n          canvas.width = mapwidth;\n          canvas.height = mapheight;\n\n          layerCanvases[name] = canvas;\n          tileEngine._r(layer, canvas.getContext('2d'));\n        }\n\n        render(canvas);\n      },\n\n      /**\n       * Simple bounding box collision test for layer tiles.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer.\n       * @param {object} object - Object to check collision against.\n       * @param {number} object.x - X coordinate of the object.\n       * @param {number} object.y - Y coordinate of the object.\n       * @param {number} object.width - Width of the object.\n       * @param {number} object.height - Height of the object.\n       *\n       * @returns {boolean} True if the object collides with a tile, false otherwise.\n       */\n      layerCollidesWith(name, object) {\n        let row = getRow(object.y);\n        let col = getCol(object.x);\n        let endRow = getRow(object.y + object.height);\n        let endCol = getCol(object.x + object.width);\n\n        let layer = layerMap[name];\n\n        // check all tiles\n        for (let r = row; r <= endRow; r++) {\n          for (let c = col; c <= endCol; c++) {\n            if (layer.data[c + r * this.width]) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      },\n\n      /**\n       * Get the tile from the specified layer at x, y or row, col.\n       * @memberof kontra.tileEngine\n       *\n       * @param {string} name - Name of the layer.\n       * @param {object} position - Position of the tile in either x, y or row, col.\n       * @param {number} position.x - X coordinate of the tile.\n       * @param {number} position.y - Y coordinate of the tile.\n       * @param {number} position.row - Row of the tile.\n       * @param {number} position.col - Col of the tile.\n       *\n       * @returns {number}\n       */\n      tileAtLayer(name, position) {\n        let row = position.row || getRow(position.y);\n        let col = position.col || getCol(position.x);\n\n        if (layerMap[name]) {\n          return layerMap[name].data[col + row * tileEngine.width];\n        }\n\n        return -1;\n      },\n\n      // expose for testing\n      _r: renderLayer,\n\n      // @if DEBUG\n      layerCanvases: layerCanvases\n      // @endif\n    }, properties);\n\n    // resolve linked files (source, image)\n    tileEngine.tilesets.forEach(tileset => {\n      let url = (kontra.assets ? kontra.assets._d.get(properties) : '') || window.location.href;\n\n      if (tileset.source) {\n        // @if DEBUG\n        if (!kontra.assets) {\n          throw Error(`You must use \"kontra.assets\" to resolve tileset.source`);\n        }\n        // @endif\n\n        let source = kontra.assets.data[kontra.assets._u(tileset.source, url)];\n\n        // @if DEBUG\n        if (!source) {\n          throw Error(`You must load the tileset source \"${tileset.source}\" before loading the tileset`);\n        }\n        // @endif\n\n        Object.keys(source).forEach(key => {\n          tileset[key] = source[key];\n        });\n      }\n\n      if (''+tileset.image === tileset.image) {\n        // @if DEBUG\n        if (!kontra.assets) {\n          throw Error(`You must use \"kontra.assets\" to resolve tileset.image`);\n        }\n        // @endif\n\n        let image = kontra.assets.images[kontra.assets._u(tileset.image, url)];\n\n        // @if DEBUG\n        if (!image) {\n          throw Error(`You must load the image \"${tileset.image}\" before loading the tileset`);\n        }\n        // @endif\n\n        tileset.image = image;\n      }\n    });\n\n    /**\n     * Get the row from the y coordinate.\n     * @private\n     *\n     * @param {number} y - Y coordinate.\n     *\n     * @return {number}\n     */\n    function getRow(y) {\n      return (tileEngine.sy + y) / tileEngine.tileheight | 0;\n    }\n\n    /**\n     * Get the col from the x coordinate.\n     * @private\n     *\n     * @param {number} x - X coordinate.\n     *\n     * @return {number}\n     */\n    function getCol(x) {\n      return (tileEngine.sx + x) / tileEngine.tilewidth | 0;\n    }\n\n    /**\n     * Render a layer.\n     * @private\n     *\n     * @param {object} layer - Layer data.\n     * @param {Context} context - Context to draw layer to.\n     */\n    function renderLayer(layer, context) {\n      context.save();\n      context.globalAlpha = layer.opacity;\n\n      layer.data.forEach((tile, index) => {\n\n        // skip empty tiles (0)\n        if (!tile) return;\n\n        // find the tileset the tile belongs to\n        // assume tilesets are ordered by firstgid\n        let tileset;\n        for (let i = tileEngine.tilesets.length-1; i >= 0; i--) {\n          tileset = tileEngine.tilesets[i];\n\n          if (tile / tileset.firstgid >= 1) {\n            break;\n          }\n        }\n\n        let tilewidth = tileset.tilewidth || tileEngine.tilewidth;\n        let tileheight = tileset.tileheight || tileEngine.tileheight;\n        let margin = tileset.margin || 0;\n\n        let image = tileset.image;\n\n        let offset = tile - tileset.firstgid;\n        let cols = tileset.columns ||\n          image.width / (tilewidth + margin) | 0;\n\n        let x = (index % tileEngine.width) * tilewidth;\n        let y = (index / tileEngine.width | 0) * tileheight;\n        let sx = (offset % cols) * (tilewidth + margin);\n        let sy = (offset / cols | 0) * (tileheight + margin);\n\n        context.drawImage(\n          image,\n          sx, sy, tilewidth, tileheight,\n          x, y, tilewidth, tileheight\n        );\n      });\n\n      context.restore();\n    }\n\n    /**\n     * Pre-render the tiles to make drawing fast.\n     * @private\n     */\n    function prerender() {\n      if (tileEngine.layers) {\n        tileEngine.layers.forEach(layer => {\n          layerMap[layer.name] = layer;\n\n          if (layer.visible !== false) {\n            tileEngine._r(layer, offscreenContext);\n          }\n        });\n      }\n    }\n\n    /**\n     * Render a tile engine canvas.\n     * @private\n     *\n     * @param {HTMLCanvasElement} canvas - Tile engine canvas to draw.\n     */\n    function render(canvas) {\n      (tileEngine.context || kontra.context).drawImage(\n        canvas,\n        tileEngine.sx, tileEngine.sy, kontra.canvas.width, kontra.canvas.height,\n        0, 0, kontra.canvas.width, kontra.canvas.height\n      );\n    }\n\n    prerender();\n    return tileEngine;\n  };\n})();\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = kontra;\n\n//# sourceURL=webpack:///./node_modules/kontra/kontra.js?");

/***/ }),

/***/ "./src/helpers/collisionHelpers.js":
/*!*****************************************!*\
  !*** ./src/helpers/collisionHelpers.js ***!
  \*****************************************/
/*! exports provided: isOverlapping */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isOverlapping\", function() { return isOverlapping; });\nvar isOverlapping = function isOverlapping(a, b) {\n  // circle vs. circle collision detection\n  // TODO: Do we not also need height?\n  var dx = a.x - b.x;\n  var dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy) < a.radius + b.width;\n};\n\n//# sourceURL=webpack:///./src/helpers/collisionHelpers.js?");

/***/ }),

/***/ "./src/helpers/physicsHelpers.js":
/*!***************************************!*\
  !*** ./src/helpers/physicsHelpers.js ***!
  \***************************************/
/*! exports provided: distance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\nvar distance = function distance(a, b) {\n  var _a = a.x - b.x;\n\n  var _b = a.y - b.y;\n\n  return Math.sqrt(_a * _a + _b * _b);\n};\n\n//# sourceURL=webpack:///./src/helpers/physicsHelpers.js?");

/***/ }),

/***/ "./src/helpers/vectorHelpers.js":
/*!**************************************!*\
  !*** ./src/helpers/vectorHelpers.js ***!
  \**************************************/
/*! exports provided: normalize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\nvar normalize = function normalize(point, scale) {\n  var norm = Math.sqrt(point.x * point.x + point.y * point.y);\n\n  if (norm != 0) {\n    // as3 return 0,0 for a point of zero length\n    point.x = scale * point.x / norm;\n    point.y = scale * point.y / norm;\n  }\n\n  return {\n    nx: point.x,\n    ny: point.y\n  };\n};\n\n//# sourceURL=webpack:///./src/helpers/vectorHelpers.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread */ \"./node_modules/@babel/runtime/helpers/objectSpread.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\");\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var kontra__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! kontra */ \"./node_modules/kontra/kontra.js\");\n/* harmony import */ var kontra__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(kontra__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _helpers_vectorHelpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers/vectorHelpers */ \"./src/helpers/vectorHelpers.js\");\n/* harmony import */ var _helpers_collisionHelpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/collisionHelpers */ \"./src/helpers/collisionHelpers.js\");\n/* harmony import */ var _helpers_physicsHelpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers/physicsHelpers */ \"./src/helpers/physicsHelpers.js\");\n/* harmony import */ var _modules_field_actionMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/field/actionMap */ \"./src/modules/field/actionMap.js\");\n\n\n/// Notes\n\n/*\r\n- Sprites don't really do much and just move when / where told to. They also have interact\r\ntriggers so we know where they are in the world.\r\n- Behind the scenes services will run and produce results based on what they're given. This could\r\nbe anything from 'turn this on because this happened' to, 'get me this as a sprite just\r\ncollided' etc.\r\n- Controls will be attached to sprites but not inside the sprites as we might need to take over\r\nthem automatically for whatever reason.\r\n- I would advise making a sort of animation state machine system that, depending on the state\r\nof a service, will trigger something off?\r\n- Don't make it complex for goodness sake, if the idea doesn't work, try another.\r\n*/\n/// Libraries\n\n/* Kontra is currently being tested, and should be swappable if a more adequate engine is found. It also doesn't\r\nsupport module loading so at present so we're using webpacks export-loader. */\n /// Helpers\n\n\n\n /// Actions\n\n /// Modules\n\n/* At present our modules shouldn't be bothered about 'how' the game loop runs, just that it does run.\r\nIdeally, we want to pass the graphics work to somewhere else, whilst these modules for example will\r\njust generated data, and separate any concerns.*/\n// import { startField } from './modules/field/module';\n// import { startBattle } from './modules/battle/module';\n/// Tests\n\nvar canvasElement = document.getElementById('canvas'); // Init the kontra engine\n\nkontra__WEBPACK_IMPORTED_MODULE_2___default.a.init(canvasElement); // Creates sprites using Kontra, adds them to a cache to be re-used for whatever needs them.\n\nvar SpriteFactory = function SpriteFactory() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    _spriteCache: []\n  };\n\n  /* Try to keep sprites in containers so there's no risk of other things\r\n  getting hold of them and weird visual stuff happening. Obviously if it's intended\r\n  that's fine, but just beware.\r\n  Wherever possible however, try to work only through the entity containers since they're\r\n  the single source of truth for all 'things' in the game world. */\n  return {\n    createSprite: function createSprite(_ref) {\n      var id = _ref.id,\n          x = _ref.x,\n          y = _ref.y,\n          color = _ref.color;\n      var newSprite = kontra__WEBPACK_IMPORTED_MODULE_2___default.a.sprite({\n        id: id,\n        x: x,\n        y: y,\n        color: color,\n        // fill color of the sprite rectangle\n        width: 20,\n        // width and height of the sprite rectangle\n        height: 40 //dx: 2          // move the sprite 2px to the right every frame\n\n      });\n      var existingCache = [newSprite].concat(options._spriteCache);\n\n      if (existingCache.filter(function (item) {\n        return item.id === id;\n      }).length > 1) {\n        console.warn('You are pushing sprites with the same ID, this is not recommended:', id);\n      }\n\n      options._spriteCache = Array.from(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(new Set(existingCache.map(function (sprite) {\n        return sprite.id;\n      })))).map(function (id) {\n        return _babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0___default()({\n          id: id\n        }, existingCache.find(function (item) {\n          return item.id === id;\n        }));\n      });\n      return newSprite;\n    },\n    getSprites: function getSprites() {\n      return options._spriteCache;\n    }\n  };\n};\n\nvar sprites = SpriteFactory(); // Entity containers\n\n/* Containers bring everything together, they make assumptions and coupling\r\nbut this should be the only place this needs to happen.\r\nAny props that are from / use a lib will be prefixed with its name.\r\n*/\n\nvar EntityContainer = function EntityContainer(_ref2) {\n  var id = _ref2.id,\n      type = _ref2.type,\n      _ref2$color = _ref2.color,\n      color = _ref2$color === void 0 ? 'red' : _ref2$color,\n      _ref2$pos = _ref2.pos,\n      pos = _ref2$pos === void 0 ? {\n    x: 0,\n    y: 0\n  } : _ref2$pos,\n      stats = _ref2.stats,\n      _ref2$actions = _ref2.actions,\n      actions = _ref2$actions === void 0 ? [] : _ref2$actions,\n      _ref2$hitbox = _ref2.hitbox,\n      hitbox = _ref2$hitbox === void 0 ? {\n    radius: 1\n  } : _ref2$hitbox;\n  // Using the factory we create a sprite matching the ID of this container (and props given)\n  var kontraSprite = sprites.createSprite({\n    id: id,\n    color: color,\n    x: pos.x,\n    y: pos.y\n  });\n\n  var _move = function _move(x, y) {\n    // Normalize in all 8 directions\n    var _normalize = Object(_helpers_vectorHelpers__WEBPACK_IMPORTED_MODULE_3__[\"normalize\"])({\n      x: x,\n      y: y\n    }, 1),\n        nx = _normalize.nx,\n        ny = _normalize.ny; // Use 'ddx' when you need acc (which we don't right now)\n\n\n    kontraSprite.dx = nx;\n    kontraSprite.dy = ny;\n    kontraSprite.advance();\n  };\n\n  var _interact = function _interact(actionReq) {\n    console.log(id, 'received signal to', actionReq);\n    var chosenAction = actions.find(function (_ref3) {\n      var id = _ref3.id;\n      return id === actionReq;\n    });\n\n    if (chosenAction) {\n      console.log('And found an action to match:');\n      console.log(chosenAction);\n    } else {\n      console.log('But no action was found.');\n    }\n  };\n\n  var _update = function _update() {\n    // Just dealing with player sprite right now, will move later\n    kontraSprite.update(); // Wrap the sprites position when it reaches\n    // the edge of the screen\n\n    if (kontraSprite.x > kontra__WEBPACK_IMPORTED_MODULE_2___default.a.canvas.width) {\n      kontraSprite.x = -kontraSprite.width;\n    }\n  };\n\n  var _render = function _render() {\n    kontraSprite.render();\n  };\n\n  return {\n    // Info\n    id: id,\n    type: type,\n    getStats: function getStats() {\n      return stats;\n    },\n    // Kontra info (used to find out where we are in the world visually)\n    x: function x() {\n      return kontraSprite.x;\n    },\n    y: function y() {\n      return kontraSprite.y;\n    },\n    width: kontraSprite.width,\n    // TODO: Make use of hitbox, don't rely on sprite.\n    height: kontraSprite.height,\n    radius: hitbox.radius,\n    // Actions\n    move: function move(_ref4) {\n      var x = _ref4.x,\n          y = _ref4.y;\n      return _move(x, y);\n    },\n    interact: function interact(actionReq) {\n      return _interact(actionReq);\n    },\n    // Kontra methods\n    update: function update() {\n      return _update();\n    },\n    render: function render() {\n      return _render();\n    }\n  };\n}; // Can use a factory to populate this later on (from map data for example)\n\n\nvar entities = [EntityContainer({\n  id: 'player-1',\n  type: 'player',\n  // TODO: Could use some consts here.\n  color: 'red',\n  pos: {\n    x: 200,\n    y: 50\n  },\n  stats: {\n    health: {\n      max: 100,\n      min: 0,\n      current: 50\n    }\n  },\n  hitBox: {\n    radius: 1\n  }\n}), EntityContainer({\n  id: 'box-1',\n  type: 'box',\n  color: 'blue',\n  pos: {\n    x: 100,\n    y: 50\n  },\n  stats: {\n    health: {\n      max: 100,\n      min: 0,\n      current: 50\n    }\n  },\n  hitBox: {\n    radius: 1\n  },\n  actions: [{\n    name: 'Open',\n    id: 'open-box',\n    do: [// ... animations, functions, etc\n    ]\n  }]\n}), EntityContainer({\n  id: 'box-2',\n  type: 'box',\n  color: 'green',\n  pos: {\n    x: 170,\n    y: 120\n  },\n  stats: {\n    health: {\n      max: 100,\n      min: 0,\n      current: 50\n    }\n  },\n  hitBox: {\n    radius: 1\n  },\n  actions: [{\n    name: 'Save The World',\n    id: 'save-the-world',\n    do: [// ... animations, functions, etc\n    ]\n  }]\n})];\nvar player = entities.find(function (_ref5) {\n  var id = _ref5.id;\n  return id === 'player-1';\n}); // Control managers\n\nvar manualControl = function manualControl(_ref6) {\n  var speed = _ref6.speed;\n  var dir = 0.1 * speed;\n  return {\n    x: kontra__WEBPACK_IMPORTED_MODULE_2___default.a.keys.pressed('right') ? dir : kontra__WEBPACK_IMPORTED_MODULE_2___default.a.keys.pressed('left') ? -dir : 0,\n    y: kontra__WEBPACK_IMPORTED_MODULE_2___default.a.keys.pressed('down') ? dir : kontra__WEBPACK_IMPORTED_MODULE_2___default.a.keys.pressed('up') ? -dir : 0\n  };\n}; // Control bindings\n\n\nkontra__WEBPACK_IMPORTED_MODULE_2___default.a.keys.bind('e', function () {\n  // player.interact((interestingData) => {\n  //     console.log(interestingData);\n  // });\n  var overlappingWithPlayer = entities.filter(function (entity) {\n    if (entity.type !== 'player') {\n      // Circle vs circle detection (still being tested, needs to use hitboxes really),\n      // at present props are a little confused with each other (x and y specifically).\n      // So that part needs a little re-working.\n      var a = {\n        x: entity.x(),\n        y: entity.y(),\n        width: entity.width,\n        radius: entity.radius\n      };\n      var b = {\n        x: player.x(),\n        y: player.y(),\n        width: player.width,\n        radius: player.radius\n      };\n      return Object(_helpers_collisionHelpers__WEBPACK_IMPORTED_MODULE_4__[\"isOverlapping\"])(a, b);\n    }\n\n    return false;\n  }).sort(function (a, b) {\n    return Object(_helpers_physicsHelpers__WEBPACK_IMPORTED_MODULE_5__[\"distance\"])({\n      x: a.x(),\n      y: a.y()\n    }, {\n      x: player.x(),\n      y: player.y()\n    }) < Object(_helpers_physicsHelpers__WEBPACK_IMPORTED_MODULE_5__[\"distance\"])({\n      x: b.x(),\n      y: b.y()\n    }, {\n      x: player.x(),\n      y: player.y()\n    });\n  }); // With distance check applied also\n\n  if (overlappingWithPlayer.length) {\n    var entity = overlappingWithPlayer[0];\n    var actionReq = Object(_modules_field_actionMap__WEBPACK_IMPORTED_MODULE_6__[\"getAction\"])({\n      id: entity.id,\n      type: entity.type\n    });\n    entity.interact(actionReq);\n  } // Useful for enemies\n  // sprites = sprites.filter(sprite => sprite.isAlive());\n\n}); // Main loop\n\nvar loop = kontra__WEBPACK_IMPORTED_MODULE_2___default.a.gameLoop({\n  update: function update() {\n    // Could just as easily be automatically controlled so we handle from outside.\n    var pos = manualControl({\n      speed: 10\n    });\n    player.move(pos); // Kontra note: Update must be called (container is entry point).\n\n    entities.forEach(function (entity) {\n      return entity.update();\n    });\n  },\n  render: function render() {\n    // Kontra note: Render must be called (container is entry point).\n    entities.forEach(function (entity) {\n      return entity.render();\n    });\n  }\n});\n\nif (player) {\n  loop.start();\n} else {\n  console.error('Loop didnt start.');\n}\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/modules/field/actionMap.js":
/*!****************************************!*\
  !*** ./src/modules/field/actionMap.js ***!
  \****************************************/
/*! exports provided: getAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAction\", function() { return getAction; });\n/*\r\nSo since we're in the field state at the moment (this is determined at the top),\r\nwe'll interact with things and expect some sort of feedback whether it be opening\r\ndoors, talking or trigger the battle module.\r\n\r\nSimply put, the type/id of thing interacted with will map back to an action map, which,\r\nfor now will just be in here.\r\n\r\nThis could exist in the global context for events or in battle too.\r\n\r\nBy default the map focuses on the type, but if an ID is given, then it's assumed a special\r\nroute must be used.\r\n*/\n// 'Should' match up to id's of action on entities. These will all come from the same\n// place eventually probably.\n// You might even import this table via json or other means outside of this map.\nvar actionMap = [{\n  name: 'Open Box',\n  // Meta\n  actionId: 'open-box',\n  // Matched action to perform\n  triggeredByType: 'box',\n  triggeredById: null\n}, {\n  name: 'Save The World',\n  actionId: 'save-the-world',\n  triggeredByType: null,\n  triggeredById: 'box-2'\n}];\nvar getAction = function getAction(_ref) {\n  var type = _ref.type,\n      id = _ref.id;\n  var actionById = actionMap.find(function (_ref2) {\n    var triggeredById = _ref2.triggeredById;\n    return triggeredById === id;\n  });\n\n  if (actionById) {\n    return actionById.actionId;\n  }\n\n  var actionByType = actionMap.find(function (_ref3) {\n    var triggeredByType = _ref3.triggeredByType;\n    return triggeredByType === type;\n  });\n  return actionByType ? actionByType.actionId : null;\n};\n\n//# sourceURL=webpack:///./src/modules/field/actionMap.js?");

/***/ })

/******/ });